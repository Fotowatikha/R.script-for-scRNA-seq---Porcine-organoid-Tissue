---
title: "Organoid annotation"
output: html_notebook
---

# In the chuck below, we load in all the essential libraries for the data analysis. 
```{r Load Libraries, echo=FALSE, results=FALSE, include=FALSE}
library(dplyr)
library(dbplyr)
library(Seurat)
library(SeuratDisk)
library(SeuratData)
library(patchwork) # Also being used for Cellchat (but main purpose was something else)
library(hdf5r)
library(tidyverse)
library(gsubfn)
library(ggplot2)
library(RColorBrewer)
library(writexl)

# For annotation, gene name conversions
library(rPanglaoDB)
library(AnnotationHub)
library(ensembldb)
library(clusterProfiler)
library(org.Hs.eg.db)
library(org.Ss.eg.db)
library(DropletUtils)
library(biomaRt)

# to download external library
library(devtools)

# for Monocle3
library(SeuratWrappers)
library(monocle3)

# plotting and data science packages
library(tidyverse)
library(cowplot)
library(patchwork) # also used for cellchat 

# co-expression network analysis packages:
# NOTE: DOWNLAOD THE "FORTRAN compiler" on Mac systems using ARM64. This compiler is not integrated in Xcode.
library(qlcMatrix)  
library(impute) 
library(preprocessCore) 
library(WGCNA)
library(hdWGCNA)

# deconvolution
library(Biobase) # install this package if needed (for simulated data)
library(BisqueRNA)

# Cellchat and dependencies:
library(NMF)
library(circlize)
library(ComplexHeatmap)
library(presto)
library(CellChat)
```

# In the chuck below we will make and combine the seurat objects of replicates and singlets
# Note that in the Seaurat@metadata, the code will automatically add an indetifier to each cell barcode from each individual object
```{r, importing the pre-processed data and merge technical replicates, warning=FALSE, echo=FALSE}
# Define paths
parent_directory = "/Users/hamid/Desktop/ABG MSc project/Raw data/Ileum Org/Non-AGGR"
sample_path = c("ileum_org_pig-F3_IL1-filtered_ref_GTF-incl_intr", "ileum_org_pig-G3_IL1_1-filtered_ref_GTF-incl_intr")
sample_names = c("ileum_Org_1", "ileum_Org_2")
project_name = "Ileum Organoid"

# Load in the pre-processed 10X data
d10x.data <- sapply(sample_path, function(i){
  d10x <- Read10X(file.path(parent_directory, i, "new-outs/counts/FilteredCounts/"))
})

# Make a vector of Seurat Objects and remove cells genes that are not expression in at least 5 cells
sobj_list <- list() 
for (i in 1:length(x = sample_path)) { 
  name <- paste('', sample_path[i], sep='') 
  sobj_list[name] <- list(CreateSeuratObject(counts = d10x.data[[i]], project = paste(sample_names[i]), min.cells = 0, min.features = 0)) 
}

# Merge the Technical replicates (if there is any) 
# NOTE: Seurat 5
if (length(sample_names) > 1) {
  for (i in 1:length(x = sobj_list)) {
  sobj <- merge(x = sobj_list[[1]], y = sobj_list[[i]]) 
  sobj <- JoinLayers(sobj, assay = "RNA") # join the layers in RNA (counts in particular, Seurat V5)
  }
} else {
  sobj <- sobj_list[[1]]
}

# UPDATE GENE NAMES
# Connect to the sscrofa database using mart
ensembl <- useMart("ensembl", dataset="sscrofa_gene_ensembl") 
# For all of our ensembl_gene_id, find all gene symbols
bm <- getBM(attributes=c("ensembl_gene_id", "hgnc_symbol"), values=rownames(sobj), mart=ensembl) # requires dbplyr 2.3.4 (by installing and restarting R, then load library)
# Find all the ENSEMBL ids in our Seurat object
ENS <- rownames(sobj@assays$RNA@features)[c(grep("ENS", rownames(sobj)))]
# Find the positions of our Seurat ENSEMBL ids in the bm output
ENSEMBL_IDs.pos <- na.omit(c(match(c(paste(ENS)), bm[,1]))) # and remove NAs (ENS with no gene IDs)
# Now find the GeneIDs in bm using the ENSEMBL_IDs.pos
geneIDs <- bm[,2][ENSEMBL_IDs.pos] 
# Since not all ENSEMBL_IDs have true gene name, we need to find the index of geneIDs with no gene name and remove their corresponding ENSEMBL_IDs
# To do this, we will remove genes with no names, and then find the index of these genesID in bm in order to find the corresponding ENSEMBL ids
geneIDs <- as.character(geneIDs[geneIDs !=""])
# Ensure that we don't replace ENSEMBL ids with gene names that could result in duplicates
duplicates <- generics::intersect(geneIDs, rownames(sobj)) # find duplicated between new gene-ids with existing ones in the Seurat object
duplicates.pos <- c(match(c(paste(duplicates)), geneIDs)) # Find position of the duplicate
geneIDs <- geneIDs[-duplicates.pos] # and remove the duplicate

geneIDs.pos <- c(match(c(paste(geneIDs)), bm[,2])) # find position of gene IDs in them
ENSEMBL_IDs <- bm[,1][geneIDs.pos] # find the ENSEMBL_IDs using the positions of the gene IDs
# Now we have found all the ENSEMBL ids that have a annotated gene name (winch are also found in our Seurat object)
# We will their final positions in our Seurat object and finally replace them with the true gene ID
# NOTE: The order of the genes are conserved using the method above
final.pos <- c(match(c(paste(ENSEMBL_IDs)), rownames(sobj)))

# replace the name of that genes for all slots
rownames(sobj@assays$RNA@features)[c(final.pos)] <- c(paste(geneIDs)) # In seurat V5 we only replace features and all slots will be updated

# replace the name of that genes for all slots in Seurat V3/4
#sobj@assays$RNA@counts@Dimnames[[1]][c(final.pos)] <- c(paste(geneIDs))
#sobj@assays$RNA@data@Dimnames[[1]][c(final.pos)] <- c(paste(geneIDs))
# rownames(sobj@assays[["RNA"]]@scale.data)[c(final.pos)] <- c(paste(geneIDs)) # This slot can only be adjusted after data scaling --- see later lines
#rownames(sobj@assays$RNA@meta.features)[c(final.pos)] <- c(paste(geneIDs))


# Change the name of the ENSSSCG00000026302 to MKI67 human homolog (w do this because of heatmap)
MKI67_gene <- "ENSSSCG00000026302"
# position/index of all genes for all slots
genes <- rownames(sobj@assays$RNA@features)
# find position of ENSSSCG00000026302
MKI67.position.sobj <- c(match(c(paste(MKI67_gene)), genes))
# replace the name of that gene to MUC2 fro all slots (Seruat V5)
rownames(sobj@assays$RNA@features)[c(MKI67.position.sobj)] <- c(paste("MKI67"))

# Change the name of the MT genes to normal (without the "-MT")
MT_genes = c("MT-ND1", "MT-ND2", "MT-COX1", "MT-COX2", "MT-ATP8", "MT-ATP6", "MT-COX3", "MT-ND3", "MT-ND4L", "MT-ND4", "MT-ND5", "MT-ND6", "MT-CYTB")
MT_genes.new = c("ND1", "ND2", "COX1", "COX2", "ATP8", "ATP6", "COX3", "ND3", "ND4L", "ND4", "ND5", "ND6", "CYTB")
 for (i in 1:length(x = MT_genes)) {
   # position/index of all genes for all slots
   genes <- rownames(sobj@assays$RNA@features)
   # find position of ENSSSCG00000026302
   MT.position.sobj <- c(match(c(paste(MT_genes[i])), genes))
   # replace the name of that gene to MUC2 fro all slots (Seruat V5)
   rownames(sobj@assays$RNA@features)[c(MT.position.sobj)] <- c(paste(MT_genes.new[i]))
 }

# replace the name of that gene to MUC2 fro all slots (Seruat V3/4)
#sobj@assays$RNA@counts@Dimnames[[1]][[MKI67.position.sobj]] <- c(paste("MKI67")) 
#sobj@assays$RNA@data@Dimnames[[1]][[MKI67.position.sobj]] <- c(paste("MKI67")) 
#rownames(sobj@assays[["RNA"]]@scale.data)[MKI67.position.sobj] <- c(paste("MKI67")) # This slot can only be adjusted after data scaling --- see later lines
#rownames(sobj@assays$RNA@meta.features)[MKI67.position.sobj] <- c(paste("MKI67"))
```


#################### EXPERIMENTAL!!! CAA integration Workflow - SKIP since we have technical replicates, we can merge! ####################


```{r show most variable genes, fig.height=5, fig.width=8, echo=FALSE, results='hide'}
# // This function calculates, plots and returns the top 3000 most variable genes based on the standardized variance
# // Input file must be a vector of Seurat objects
most_var_genes <- function(sobj) {
  sobj <- FindVariableFeatures(sobj, selection.method = "vst", nfeatures = 3000) #### AOTOMATE THE NUMBER OF VARIABLES
  return(sobj)
}
# Execute most_var_genes function
sobj_list <- sapply(sobj_list, most_var_genes)

# Now we select features that are repeatedly variable across datasets for integration

# Gene selection for input to CCA:
# take the names of the higly variable genes for each Seurat object
#g.1 <- head(rownames(HVFInfo(object = sobj_list[[1]])), 3000)
#g.2 <- head(rownames(HVFInfo(object = sobj_list[[2]])), 3000)
# Remove duplicate by taking unique ones of the two
#highly_variable_feautures <- unique(c(g.1, g.2))
#highly_variable_feautures <- intersect(highly_variable_feautures, rownames(GetAssayData(object = sobj_list[[1]], slot = "scale.data")))
#highly_variable_feautures <- intersect(highly_variable_feautures, rownames(GetAssayData(object = sobj_list[[2]], slot = "scale.data")))


# The features for RPCA
highly_variable_feautures <- SelectIntegrationFeatures(object.list = sobj_list, nfeatures = 3000)
```

```{r scaling of the data, results='hide', fig.height=10, fig.width=7}
# // This function shifts the expression of each gene, so that the mean expression across cells is 0 
# // This functions scales the expression of each gene, so that the variance across cells is 1
# // The funtion returns the sclaed results to object@scale.data for each Seurat object
# // Input file must be a vector of Seurat objects
scaling <- function(sobj) {
  all.genes.sobj <- rownames(sobj)
  sobj <- ScaleData(sobj, features = all.genes.sobj) 
  return(sobj)
}
# Execute scaling function
sobj_list <- sapply(sobj_list, scaling)
```

```{r scaling and PCA, results='hide', fig.height=4, fig.width=8}
# // This function runs a PCA on the 2500 most variable each Seaurat object 
# // By default up to 100 PCs are calculated
# // Input file must be a vector of Seurat objects
run_PCA <- function(sobj) {
  sobj <- RunPCA(sobj, features = VariableFeatures(object = sobj))
  return(sobj)
}
# Execute run_PCA function
sobj_list <- sapply(sobj_list, run_PCA)

# // This function calculates returns the optimal number of PCs for clustering.
# // Method1: last PC where change in percent variation is more than 0.5%
# // Method2: PCs representing cumulative percent >90% and less than 5% associated with the single PC
# // Input file must be a vector of Seurat objects
optimal_PCs <- function(sobj) {
  pc.stdev.percentage <- sobj[["pca"]]@stdev / sum(sobj[["pca"]]@stdev) * 100 # find standard deviation for each PC
  cumu.percentage <- cumsum(pc.stdev.percentage) # find cumulative percentages for PCs
  co1 <- which(cumu.percentage > 90 & pc.stdev.percentage < 5)[1] # find PCs representing cumulative percent >90% and less than 5% associated with the single PC
  co1 # list PC
  co2 <- sort(which((pc.stdev.percentage[1:length(pc.stdev.percentage) - 1] - pc.stdev.percentage[2:length(pc.stdev.percentage)]) > 0.05), 
              decreasing = T)[1] + 1 # find last PC where change in percent variation is more than 0.5%
  co2 # list PC
  pcs <- min(co1, co2) # find the minimum PC from the 2 methods used above
  pcs < max(pcs) # list P
  pc.dims <- 1:pcs # we will use these dimenion later on
  
  plot_df <- data.frame(pc.stdev.percentage = pc.stdev.percentage, # put PC values into dataframe for plotting
                      cumu = cumu.percentage, 
                      rank = 1:length(pc.stdev.percentage))
  
  opt_PC_plot <- ggplot(plot_df, aes(cumu.percentage, pc.stdev.percentage, label = rank, color = rank > pcs)) + 
    geom_text() + geom_vline(xintercept = 90, color = "grey") + 
    geom_hline(yintercept = min(pc.stdev.percentage[pc.stdev.percentage > 5]), color = "grey") + theme_bw() # visualize PCs to use in elbow plot
  print(opt_PC_plot)
  
  return(list(pc.dims))
}
# Execute optimal_PC function
pc.dims <- sapply(sobj_list, optimal_PCs)

# Plot an Eblow to visualize the optimal PCs
for (i in 1:length(x = pc.dims)) {
  e1 <- ElbowPlot(sobj_list[[i]], ndims = 40) + 
    ggtitle(paste("Elbow Plot - Most Significant PCs", sobj_list[[i]]@meta.data$cell.origin[1], sep = " - ")) + 
    geom_vline(xintercept = max(unlist(pc.dims[[i]])), linetype="dashed", color = "red", size=1)
  print(e1) ####### SAVE FOR PIPELINE
}

# Find the lowest PC dim from a list of PC.dims that can be used for RPCA/CCA
dims <- 0
for (i in 1:length(x = pc.dims)) {
  dims[i] <- max(pc.dims[[i]])
}
dims <- 1:min(dims) # final number of dims
```

```{r Perform CCA or RPCA integration, echo=FALSE}
# find anchors rPCA
#find.anchors <- FindIntegrationAnchors(object.list = sobj_list, anchor.features = highly_variable_feautures, reduction = "rpca")
# Now we creates the 'integrated' data assay
#org.tiss.combined <- IntegrateData(anchorset = find.anchors, k.weight = 105)

# find anchors CCA
find.anchors <- FindIntegrationAnchors(object.list = sobj_list, anchor.features = highly_variable_feautures, reduction = "cca", dims = 1:15)
# Now we creates the 'integrated' data assay
org.tiss.combined <- IntegrateData(anchorset = find.anchors, dims = 1:15)
```

```{r applying workflow on filtered data, fig.height=4, fig.width=5, echo=FALSE}
# Scale the data
#org.tiss.combined <- NormalizeData(object = org.tiss.combined, assay = "RNA")
all.genes.org.tiss.combined <- rownames(org.tiss.combined)
org.tiss.combined <- ScaleData(org.tiss.combined, features = all.genes.org.tiss.combined) 
# PCA using selected features
org.tiss.combined <- RunPCA(org.tiss.combined, features = VariableFeatures(object = org.tiss.combined)) 
pc.stdev.percentage <- org.tiss.combined[["pca"]]@stdev / sum(org.tiss.combined[["pca"]]@stdev) * 100 
cumu.percentage <- cumsum(pc.stdev.percentage) 
co1 <- which(cumu.percentage > 90 & pc.stdev.percentage < 5)[1] 
co2 <- sort(which((pc.stdev.percentage[1:length(pc.stdev.percentage) - 1] - pc.stdev.percentage[2:length(pc.stdev.percentage)]) > 0.05), decreasing = T)[1] + 1 
pcs <- min(co1, co2) 
pc.dims <- 1:pcs # This (13) is the optimal PC for Orgnaoid

# UMAP/T-SNE clustering

org.tiss.combined <- FindNeighbors(org.tiss.combined, dims = pc.dims)
org.tiss.combined <- FindClusters(org.tiss.combined, resolution = c(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0)) # Try several resolutions
org.tiss.combined <- RunUMAP(org.tiss.combined, dims = pc.dims) # UMAP

# plot UMAP and t-SNE at different resolutions
resolutionList <- grep("_snn_res", colnames(org.tiss.combined@meta.data), value = TRUE) # copy patern of the resolutions
for (i in resolutionList) {
  plot_res_UMAP <- DimPlot(org.tiss.combined, group.by = i, label = TRUE, pt.size = 0.05, reduction = 'umap') + ggtitle(paste(i, project_name, sep = " - ")) + ylab("UMAP 1") + xlab("UMAP 2")  
  print(plot_res_UMAP)
} 
```

```{r final cluster, fig.height=4, fig.width=5, echo=FALSE} 
# setting final cluster
Idents(org.tiss.combined) <- "integrated_snn_res.0.9"
DimPlot(org.tiss.combined, reduction = 'umap', label = T, pt.size = 0.1) + ggtitle(project_name, subtitle = paste("Preleminary Clustering (n = ", paste(dim(sobj)[2], ")", sep = ""))) + ylab("UMAP 1") + xlab("UMAP 2")

DefaultAssay(org.tiss.combined) <- "RNA"

org.tiss.combined <- NormalizeData(object = org.tiss.combined, assay = "RNA")
org.tiss.combined <- ScaleData(org.tiss.combined, verbose = FALSE,assay = "RNA")

org.tiss.combined 
```



#################### Standard Workflow (for technical replicates) ####################



# In the chuck below we will apply the our previous workflow starting with the normalization, feauture selection, sclaing, PCA, clustering and DGE analysis
# For the clustering, we will analyze all clusters manually and select the best.
# This process is recursive, so we try many times
```{r applying workflow on filtered data, fig.height=4, fig.width=5, echo=FALSE}
# Normalization
sobj <- NormalizeData(sobj, normalization.method = "LogNormalize", scale.factor = 10000) 
# Most variable feature selection
sobj <- FindVariableFeatures(sobj, selection.method = "vst", nfeatures = 2300) # We decreased the number of informative features for organoids as it represent low complexity cells (previously 2500)
# Scale the data
all.genes.sobj <- rownames(sobj)
sobj <- ScaleData(sobj, features = all.genes.sobj) 
#rownames(sobj@assays[["RNA"]]@scale.data)[c(final.pos)] <- c(paste(geneIDs)) # HERE WE UPDATE THE GENE NAME IN THE SCALED SLOT (SEE PREVIOUS) (SEURAT V3/4)
#rownames(sobj@assays[["RNA"]]@scale.data)[MKI67.position.sobj] <- c(paste("MKI67")) # HERE WE UPDATE THE GENE NAME IN THE SCALED SLOT (SEE PREVIOUS) (SEURAT V3/4)
# PCA using selected features
sobj <- RunPCA(sobj, features = VariableFeatures(object = sobj)) 
pc.stdev.percentage <- sobj[["pca"]]@stdev / sum(sobj[["pca"]]@stdev) * 100 
cumu.percentage <- cumsum(pc.stdev.percentage) 
co1 <- which(cumu.percentage > 90 & pc.stdev.percentage < 5)[1] 
co2 <- sort(which((pc.stdev.percentage[1:length(pc.stdev.percentage) - 1] - pc.stdev.percentage[2:length(pc.stdev.percentage)]) > 0.01), decreasing = T)[1]  
pcs <- min(co1, co2) 
pc.dims <- 1:pcs
# UMAP/T-SNE clustering
sobj <- FindNeighbors(sobj, dims = pc.dims)
sobj <- FindClusters(sobj, resolution = 1.4) # 1.4 is a good start for ileum organoid.
#sobj <- FindClusters(sobj, resolution = c(0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0, 2.1, 2.2, 2.3, 2.4, 2.5)) # Try several resolutions
sobj <- RunUMAP(sobj, dims = pc.dims) # UMAP
#sobj <- RunTSNE(sobj, dims = pc.dims) # T-SNE

# plot UMAP and t-SNE at different resolutions
#resolutionList <- grep("_snn_res", colnames(sobj@meta.data), value = TRUE) # copy patern of the resolutions
#for (i in resolutionList) {
#  plot_res_UMAP <- DimPlot(sobj, group.by = i, label = TRUE, pt.size = 0.05, reduction = 'umap') + ggtitle(paste(i, project_name, sep = " - ")) + ylab("UMAP 1") + xlab("UMAP 2")
#  print(plot_res_UMAP)
#} 
```
# In the chuck below, we choose the preleminary cluster based on expectation and visualize
```{r final cluster, fig.height=4, fig.width=5, echo=FALSE} 
# setting final cluster
Idents(sobj) <- "seurat_clusters" # RNA_snn_res.1 or seurat_clusters
DimPlot(sobj, reduction = 'umap', label = TRUE, pt.size = 0.1) + ggtitle(project_name, subtitle = paste("Preleminary Clustering (n = ", paste(dim(sobj)[2], ")", sep = ""))) + ylab("UMAP 1") + xlab("UMAP 2")

sobj@meta.data
```


#################### DGE ANALYSIS ####################


# Markers are being determined by the Wilxoc sum of ranks where the means of expression of one gene is compared to other clusters
# min.pct determines that we want at least 10% of the cells between the groups to have a expression of that gene. The reason we are being little generous here is because not all genes will be detected in a cell, even if it is (highly) expressed.
# We set Log2FC at 0.1 in order to detect low signal as well. This paramter determines the minimum log2 foldchange for average expression of gene in cluster relative to the average expression in all other clusters combined. Setting this too high will result in loss of signal, and too low could yield some ribosomal genes, but that is not a problem and can be igorned.
# The min.diff.pct determines the minimum percent difference between the percent of cells expressing the gene in the cluster and the percent of cells expressing gene in all other clusters combined. Ideally we want a large difference between the cluster and the rest of the cluser, but, this could miss those cell markers that are expressed in all cells, but are highly up-regulated in this specific cell type. Therefore, we must manually inspect all genen. For this reason, we set this parameter on 0.25, but we will mannually look for large differences as well.
# In the chuck below, we will also import annotation infromation and merge this with the DE gene table.
```{r markers1, fig.height=3, fig.width=4, echo=FALSE}
# Connect to AnnotationHub
ann.hub <- AnnotationHub()
# Access the Ensembl database for pig
ann.hub.database <- query(ann.hub, pattern = c("Sus scrofa", "EnsDb"), ignore.case = TRUE)
# Acquire the latest annotation files
id <- ann.hub.database %>%
        mcols() %>%
        rownames() %>%
        tail(n = 1)
# Downloading the Ensembldb database
ensembl.database <- ann.hub[[id]]
# Extract gene-level information from the database
annotations <- genes(ensembl.database, 
                     return.type = "data.frame")
# Select annotations of interest
annotations <- annotations %>%
        dplyr::select(gene_id, gene_name, seq_name, gene_biotype, description)

# find all markers of cluster 2
#cluster6.markers <- FindMarkers(ileum.org.incl.intr.seu, ident.1 = 3, min.pct = 0.25, logfc.threshold = 0.25, min.diff.pct = 0.4)
#cluster6.markers %>% slice_max(n = 30, order_by = avg_log2FC) # show first 5
# find all markers distinguishing cluster 5 from clusters 0 and 3
#cluster5.markers <- FindMarkers(ileum.org.incl.intr.seu, ident.1 = 5, ident.2 = c(0, 3), min.pct = 0.25)
#head(cluster5.markers, n = 10)

# find markers for every cluster compared to all remaining cells, report only the positive ones
sobj.markers <- FindAllMarkers(sobj, only.pos = TRUE, min.pct = 0.15, logfc.threshold = 0.1) #  min.diff.pct = 0.20
sobj.markers <- subset(sobj.markers, p_val_adj < 0.05) # make sure the adjusted p-values are still < 0.05 since some genes in DE list have p_val_adj > 0.05
markers <- sobj.markers %>% group_by(cluster) %>% slice_max(n = 100, order_by = avg_log2FC)
features <- annotations[c("gene_biotype", "description", "gene_name")] # subset only the columns of gene symbols, Ensembl IDs, and the names used for analysis 
markers <- merge(markers,
              features, 
              by.x = "gene", 
              by.y = "gene_name") # merge the DE gene lists with the additional gene information

# Put markers per cluste rin data.frame and order them
markers <- markers[order(markers$cluster, markers$p_val_adj),] # reorder by lowest to highest p-value within each cluster
markers
#ann.markers <- markers %>% 
#                rownames_to_column(var="gene") %>% 
#                left_join(y = unique(annotations[, c("gene_name", "description")]),
#                          by = c("gene" = "gene_name")). # genes name must be unique here

# lets save the markers for later
if (dir.exists(file.path(parent_directory, "/Results/DE Markers"))) {
  write_xlsx(data.frame(markers), paste(parent_directory, "/Results/DE Markers/markers.xlsx", sep = ""))
} else {
  dir.create(file.path(parent_directory, "/Results/DE Markers"), recursive = TRUE)
  write_xlsx(data.frame(markers), paste(parent_directory, "/Results/DE Markers/markers.xlsx", sep = ""))
}
```


#################### GO and KEGG on DGE genes ####################


# In the two chuck below we will check each cluster by performing a GO and KEGG enrichments analysis.
# Here we will focus on upregulated genes only as a first impression of the type of cells
```{r GO enrichment on the DE genes, fig.height=15, fig.width=8, echo=FALSE}
# Extract op genes of interest
sobj.markers %>% group_by(cluster) %>% top_n(n = 100, wt = avg_log2FC) -> top100
top100 <- top100[order(top100$cluster, top100$p_val_adj),] 
top100

# or all of them
markers <- markers[order(markers$cluster, markers$p_val_adj),] # reorder by lowest to highest p-value within each cluster
markers

#Extract the markers that positive expression per cluster
GO.KEGG.sampels.pos <- markers[,1:7]   # extract the top 30 genes and clusters containing only the positive Log2FC
GO.KEGG.sampels.pos <- split(GO.KEGG.sampels.pos$gene, GO.KEGG.sampels.pos$cluster)

# Prepare the GO KEGG analysis for the DE up-regulated markers using the PIG database
for (i in 1: length(GO.KEGG.sampels.pos)) {
  GO.KEGG.sampels.pos[[i]] = bitr(GO.KEGG.sampels.pos[[i]], fromType="SYMBOL", toType="ENTREZID", OrgDb="org.Hs.eg.db") # org.Hs.eg.db for human
}
# do the same here, a line like below for each cluster
genelist.all.pos <- list()
for (i in 1: length(GO.KEGG.sampels.pos)) {
  genelist.all.pos[paste(i - 1)] <- list(GO.KEGG.sampels.pos[[i]]$ENTREZID)
}

# HUMANS DATABASE
GOclusterplot.all.pos.hs <- compareCluster(geneCluster = genelist.all.pos, fun = "enrichGO", OrgDb = "org.Hs.eg.db", ont = 'BP', pvalueCutoff  = 0.05)
dotplot(GOclusterplot.all.pos.hs, showCategory=4) + ggtitle(paste("GO: Up-regulated Markers", project_name, sep = " - ")) 
# PIG DATABSE
# Do the GO and KEGG on biological process on DE up-regulated markers
GOclusterplot.all.pos <- compareCluster(geneCluster = genelist.all.pos, fun = "enrichGO", OrgDb = "org.Ss.eg.db", ont = 'BP', pvalueCutoff  = 0.05)
dotplot(GOclusterplot.all.pos, showCategory=4) + ggtitle(paste("GO: Up-regulated Markers", project_name, sep = " - ")) #+ coord_flip() + theme(axis.text.x = element_text(angle=90))
```

```{r KEGG enrichment on the DE genes, fig.height=7.5, fig.width=14, echo=FALSE}
# PIG DATABSE
# KEGG
# suported orgnaism can ben found here: https://www.genome.jp/kegg/catalog/org_list.html
KEGGclusterplot.all.pos <- compareCluster(geneCluster = genelist.all.pos, fun = "enrichKEGG", organism = "ssc", pvalueCutoff  = 0.05)
dotplot(KEGGclusterplot.all.pos) + ggtitle(paste("KEGG: Up-regulated Markers", project_name, sep = " - ")) + coord_flip() + theme(axis.text.x = element_text(angle=90))

# HUMANS DATABASE
# KEGG
#KEGGclusterplot.all.pos.hs <- compareCluster(geneCluster = genelist.all.pos, fun = "enrichKEGG", organism = "hsa", pvalueCutoff  = 0.05,)
#dotplot(KEGGclusterplot.all.pos.hs) + ggtitle("KEGG - Hs: Up-regulated Markers - Pig Ileum Organoid") 
```


#################### Analysis and visualization of Markers ###################


# In the chuck below we make dotplots of DGE per cell type or subset
```{r Dotplot, fig.height=30, fig.width=30, echo=FALSE}
# Collect top DEGs of interest
sobj.markers %>% group_by(cluster) %>% top_n(n = 100, wt = avg_log2FC) -> top100
top100 <- top100[order(top100$cluster, top100$p_val_adj),] 
top100

# Dotplot
DotPlot(sobj, features = top100, assay = "RNA", scale = T, scale.by = 'size') + scale_colour_gradient2(low = "blue", mid = "white", high = "red") +
  RotatedAxis() +
  geom_point(aes(size=pct.exp), shape = 21, colour="black", stroke=0.7)
```

# Heatmap
```{r Heatmap, fig.height=9, fig.width=14, echo=FALSE}
# Collect top DEGs of interest
sobj.markers %>% group_by(cluster) %>% top_n(n = 10, wt = avg_log2FC) -> top100
top100 <- top100[order(top100$cluster, top100$p_val_adj),] 
top100

# Heatmap 
DoHeatmap(subset(sobj, downsample = 200), features = top100, assay = "RNA", label = TRUE) + scale_fill_gradientn(colors = c("darkturquoise", "white", "red")) #+ NoLegend()
```

# In the chuck below we will display the most relevant DE or known marker genes per cluster
```{r plot marker genes, fig.height=10, fig.width=10, echo=FALSE}
#################### BASIC ANNOTATION of ILEUM ORG ###################

# Progenitor/Stem/Transient amplyfying cells #
# Mostly enriched in Cluster 1, 7 and 11 (and low in 6 and 8).
# Highly specific in Cluster 1 with no signature of other markers, making this cluster "Progenitor/Stem cells"
# Cluster 8 shows loer expression of the stem cell genes, but they are expressed.
FeaturePlot(sobj, features = c("CENPF", "HMGB2", "TPX2", "UBE2C", "TOP2A", "MKI67"),cols = c("grey", "red"),  pt.size = 0.5, reduction = "umap", label = T) + ylab("UMAP 1") + xlab("UMAP 2")
VlnPlot(sobj, features = c("CENPF", "HMGB2", "TPX2", "UBE2C", "TOP2A", "BNIP3"), slot = 'counts', log = FALSE)
# Actual Stem cells (Human, also Pig)
FeaturePlot(sobj, features = c("OLFM4", "CDCA7", "SOX9"),cols = c("grey", "red"),  pt.size = 0.5, reduction = "umap", label = T) + ylab("UMAP 1") + xlab("UMAP 2") 

# Absorptive lineage differentiation genes.
FeaturePlot(sobj, features = c("ELF3", "CTNNB1", "RB1", "TGFBR2", "HES1"),cols = c("grey", "red"),  pt.size = 0.5, reduction = "umap", label = T) + ylab("UMAP 1") + xlab("UMAP 2") 

FeaturePlot(sobj, features = c("BACH1", "FOSL2", "JDP2", "FOSL1", "JUNB", "MAFF"),cols = c("grey", "red"),  pt.size = 0.5, reduction = "umap", label = T) + ylab("UMAP 1") + xlab("UMAP 2") 
FeaturePlot(sobj, features = c("ATF3", "PPARG", "HNF4A", "NR1I2", "HNF4G", "NR5A2"),cols = c("grey", "red"),  pt.size = 0.5, reduction = "umap", label = T) + ylab("UMAP 1") + xlab("UMAP 2") 
FeaturePlot(sobj, features = c("NR6A1", "RXRB", "ESRRG", "CEBPB"),cols = c("grey", "red"),  pt.size = 0.5, reduction = "umap", label = T) + ylab("UMAP 1") + xlab("UMAP 2") 

FeaturePlot(sobj, features = c('EPCAM', 'FABP2', 'GUCA2B', 'VNN1', 'SLC26A6'),cols = c("grey", "red"),  pt.size = 0.5, reduction = "umap", label = T) + ylab("UMAP 1") + xlab("UMAP 2") 
FeaturePlot(sobj, features = c("CDK6", "CPSF6", "SPP1", "OLFM4", "SPAI-2", "SPINK1"),cols = c("grey", "red"),  pt.size = 0.5, reduction = "umap", label = T) + ylab("UMAP 1") + xlab("UMAP 2") 
FeaturePlot(sobj, features = c("C3", "PIGR", "C4BPA", "DAB2", "CFP", "SOD3", "C5", "CDCA7", 'RABGAP1L', "ALDH1A1"),cols = c("grey", "red"),  pt.size = 0.5, reduction = "umap", label = T) + ylab("UMAP 1") + xlab("UMAP 2") 


# Activated Enterocyte Progenitor #
# Proliferating stem, progenitor or cancer cells require the activation of CDK4/6, and cluster 7 (Enterocytes Progenitors) is highly enriched for both, and express MCM2-7, CCNB1/CDC20 and MKI67, suggesting high-activity
# All other cluster show lower expression of CDK4/6, with 7 being the highest for both. Cluster 7 also expressed DNMT1 which is essential for progenitor maintenance and highly proliferating cells in general.
FeaturePlot(sobj, features = c("CDK4", "CDK6", "DNMT1"),cols = c("grey", "red"),  pt.size = 0.5, reduction = "umap", label = T) + ylab("UMAP 1") + xlab("UMAP 2") 
VlnPlot(sobj, features = c("CDK4", "CDK6", "DNMT1"), slot = 'counts', log = FALSE)

# Early Epithelial Enterocytes #
# Enriched for genes related to micophillus formation and expressed in almost all cells
# Highest expression in cluster 0 showing no sign of stem/progenitor gene signature, making it "Early Epithelial Enterocytes"
# Cluster 7 and (11) also show high expression of these genes, including stem/progenitor gene signature making them "Enterocytes Progenitors"
FeaturePlot(sobj, features = c("ACTB", "PLS1", "VIL1" ,"EPS8", "EZR", "MYO6", "MYO1A", "KRT18", "KRT8", "KRT19"),cols = c("grey", "red"),  pt.size = 0.5, reduction = "umap", label = T) + ylab("UMAP 1") + xlab("UMAP 2") 
VlnPlot(sobj, features = c("ACTB", "PLS1", "VIL1" ,"EPS8", "EZR", "MYO6", "MYO1A", "KRT18", "KRT8"), slot = 'counts', log = FALSE)

# Mature (Migrating) Enterocytes #
# These genes are exclusively expressed in cluster 10 and often found in developing and tip of epithelial Enterocytes, making these "Mature (Migrating) Enterocytes"
FeaturePlot(sobj, features = c("MSN" ,"MMP7", "LGALS1", "MMP13"),cols = c("grey", "red"),  pt.size = 0.5, reduction = "umap", label = T) + ylab("UMAP 1") + xlab("UMAP 2") 
VlnPlot(sobj, features = c("MSN" ,"MMP7", "LGALS1", "MMP13"), slot = 'counts', log = FALSE)

# Mature Goblet cells #
# Highly enriched and specific in Cluster 13, which makes these cluster "Mature goblet cells"
FeaturePlot(sobj, features = c("TFF3", "SPINK4", "REG4", "MUC2"),cols = c("grey", "red"), pt.size = 1, label = T) 
VlnPlot(sobj, features = c("TFF3", "SPINK4", "REG4", "MUC2"), slot = 'counts', log = FALSE)

# MCM2-7 Proliferating cells #
# Highly enriched in cluster 7 (activated Enterocytes Progenitor), 11 (Prolifirating Stem Cells) and 6.
# Due to expression in cluster 7 with MKI67, it makes these progenitor erythrocytes a proliferating type. 
# Since these genes are also expressed in cluster 11, that also has stem cell signature, including proliferation factor MKI67, these are classified as "Proliferating stem cells/enterocyte prog"
FeaturePlot(sobj, features = c("MCM2", "MCM5", "MCM6", "MCM7", "POLA1"),cols = c("grey", "red"),  pt.size = 0.5, reduction = "umap", label = T) + ylab("UMAP 1") + xlab("UMAP 2") # Expressed in early G1 and required for S phase
VlnPlot(sobj, features = c("MCM2", "MCM5", "MCM6", "MCM7", "POLA1"), slot = 'counts', log = FALSE)

# Enteroendocrine cells (PART OF GOBLET CLUSTER) #
# Within cluster 13 we find minor signature of markers for "Enteroendocrine cells"
FeaturePlot(sobj, features = c("NEUROG3", "NEUROD1", "PAX4", "CHGA"),cols = c("grey", "red"),  pt.size = 1, reduction = "umap", label = T) + ylab("UMAP 1") + xlab("UMAP 2") 
VlnPlot(sobj, features = c("NEUROG3", "NEUROD1", "PAX4", "CHGA"), slot = 'counts', log = FALSE)

#### EXTRAS INFO ####

# Canonical marker for Ileum Epithelium #
# We observe that almost all cell show signature of the epithelium in the organoid
FeaturePlot(sobj, features = c("EPCAM", "KRT8", "KRT18", "KRT19", "KRT20"),cols = c("grey", "red"), pt.size = 0.5, reduction = "umap", label = T) + ylab("UMAP 1") + xlab("UMAP 2")
VlnPlot(sobj, features = c("EPCAM", "KRT8", "KRT18", "KRT19"), slot = 'counts', log = FALSE)

# Canonical marker for Crypt region (high protein translation) # 
# We observe that almost all cell show signature of the Crypt (or high protein translation) region
FeaturePlot(sobj, features = c("RPS6", "EEF1B2"),cols = c("grey", "red"),  pt.size = 1, reduction = "umap", label = T) + ylab("UMAP 1") + xlab("UMAP 2") 
VlnPlot(sobj, features = c("RPS6", "EEF1B2"), slot = 'counts', log = FALSE)

# G2/M (anaphase) transit-amplifying (Prog/Stem) cells or ()#
# Expression of G2/M Anaphase genes in cluster 8 with Lower expression of stem cell genes and no expression of CDK4/6  makes this "G2/M (Anaphase) transit-amplifying (Prog/Stem) cells"
# Down regulation of ARID1A in cluster 8 results in up regulation of "CCNB1" ,"CDC20", which is common in TAC.
FeaturePlot(sobj, features = c("ARID1A", "CCNB1" ,"CDC20", "CDK1"),cols = c("grey", "red"),  pt.size = 0.5, reduction = "umap", label = T) + ylab("UMAP 1") + xlab("UMAP 2")   
 
# H2AC6, H2AC4, H2AC20 are expressed in the S phase and specifically more expressed in majority of cells in CLuster 11.
# Cluster 11 also shows strong signature of Stem/Prog genes, and show strong signature of activated erythrocyte progenitor cells (custer 7)
FeaturePlot(sobj, features = c("H2AC6" ,"H2AC4", "H2AC20"),cols = c("grey", "red"),  pt.size = 0.5, reduction = "umap", label = T) + ylab("UMAP 1") + xlab("UMAP 2") 

# Entering G0, by down regulation of MCM-2-7, CDC6 and CDT1 is common in quencient cells
FeaturePlot(sobj, features = c("MCM2" ,"CDT1", "CDC6"),cols = c("grey", "red"),  pt.size = 0.5, reduction = "umap", label = T) + ylab("UMAP 1") + xlab("UMAP 2") 
VlnPlot(sobj, features = c("MCM2" ,"CDT1", "CDC6"), slot = 'counts', log = FALSE)

# CDKN1A repressed CDK4/6 and thus stop cell differentiation (nondividing cells, not going into S phase). 
# CDK6 by itself also stop cell differentiation in the absence of CDK4, and early/late enterocytes (cluster 0 and 10 (and 2)) show high expression of CDKN1A (and CDK6) and no CDK4 and MKI67
FeaturePlot(sobj, features = c("CDKN1A", "ENSSSCG00000026302", "CDK4", "CDK6", "MCM3"),cols = c("grey", "red"),  pt.size = 0.5, reduction = "umap", label = T) + ylab("UMAP 1") + xlab("UMAP 2") 
VlnPlot(sobj, features = c("CDKN1A", "ENSSSCG00000026302", "CDK4", "CDK6", "MCM3"), slot = 'counts', log = FALSE)


# Checing some DEGs
FeaturePlot(sobj, features = c("SPDEF" ,"ATOH1" ,"HES1", "UBE2C", "SPINK4", "REG4"),cols = c("grey", "red"),  pt.size = 1, reduction = "umap", label = T) + ylab("UMAP 1") + xlab("UMAP 2") 
VlnPlot(sobj, features = c("BNIP3", "ENSSSCG00000026302", "CDK4", "CDK6", "MCM3"), slot = 'counts', log = FALSE)
FeaturePlot(sobj, features = c("EGFR", "ENSSSCG00000026302", "MCM7"),cols = c("grey", "red"),  pt.size = 0.5, reduction = "umap", label = T) + ylab("UMAP 1") + xlab("UMAP 2") 
VlnPlot(sobj, features = c("EGFR", "ENSSSCG00000026302", "MCM7", "ENSSSCG00000026302"), slot = 'counts', log = FALSE)
FeaturePlot(sobj, features = c("PTPN11", "MAP2K1"),cols = c("grey", "red"),  pt.size = 0.5, reduction = "umap", label = T) + ylab("UMAP 1") + xlab("UMAP 2") 
FeaturePlot(sobj, features = c("BNIP3", "TFF3", "UNG"),cols = c("grey", "red"),  pt.size = 0.5, reduction = "umap", label = T) + ylab("UMAP 1") + xlab("UMAP 2") 
FeaturePlot(sobj, features = c("TCEA1", "AICDA", "KIAA0040"),cols = c("grey", "red"),  pt.size = 0.5, reduction = "umap", label = TRUE) + ylab("UMAP 1") + xlab("UMAP 2") 

####### Mature Enterocyte Markers ########  
# These are genes related to metabolism and absorptive molecules
FeaturePlot(sobj, features = c("FABP1", "FABP2", "SLC5A1", "APOA1", "APOA4", "ACE2", "SI", "FABP6"),cols = c("grey", "red"),  pt.size = 2, reduction = "umap") + ylab("UMAP 1") + xlab("UMAP 2")
# Enterocyte development genes (microvillus)
FeaturePlot(sobj, features = c("ACTB", "PLS1", "VIL1" ,"EPS8", "EZR", "MYO6", "MYO1A", "KRT18", "KRT8", "KRT19"),cols = c("grey", "red"),  pt.size = 0.5, reduction = "umap", label = TRUE) + ylab("UMAP 1") + xlab("UMAP 2") 
# Other general Enterocyte markers, these do not seem to be expressed in ealy-enteroytes
FeaturePlot(sobj, features = c("APOA4", "DPEP1", "ANPEP", "APOB", "ASS1", "FABP2", "APOC3", "RBP2"),cols = c("grey", "red"),  pt.size = 0.5, reduction = "umap", label = TRUE) + ylab("UMAP 1") + xlab("UMAP 2")
FeaturePlot(sobj, features = c("SLC5A12", "SLC1A1", "SLC5A1", "SLC51A", "SLC7A9", "ALDOB"),cols = c("grey", "red"),  pt.size = 0.5, reduction = "umap", label = TRUE) + ylab("UMAP 1") + xlab("UMAP 2")

# Panneth/Goblet faith:
FeaturePlot(sobj, features = c("PTPN11", "MAP2K1", "PLA2G1B"),cols = c("grey", "red"),  pt.size = 2, reduction = "umap") + ylab("UMAP 1") + xlab("UMAP 2")

# Secretory faith
FeaturePlot(sobj, features = c("HES1", "ATOH1", "SPDEF", "GFI1", "MAML3", "DLL4"),cols = c("grey", "red"),  pt.size = 2, reduction = "umap") + ylab("UMAP 1") + xlab("UMAP 2")

# TEST EXTRA
#paneth
FeaturePlot(sobj, features = c("BPI", "CA8", "FCN2", "PIGR", "C3", "SPINK1"),cols = c("grey", "red"),  pt.size = 2, reduction = "umap") + ylab("UMAP 1") + xlab("UMAP 2")
#goblet
FeaturePlot(sobj, features = c("TCN1", "TFF2", "CLCA1", "ITLN2", "SPDEF"),cols = c("grey", "red"),  pt.size = 2, reduction = "umap") + ylab("UMAP 1") + xlab("UMAP 2")

# Just testing
FeaturePlot(sobj.org, features = c('WNT7B', 'NOTCH2', 'NOTCH3', 'NOTCH4', 'DLL1', 'DLL2', 'DLL3', 'DLL4'),cols = c("grey", "red"),  pt.size = 0.5, reduction = "umap") + ylab("UMAP 1") + xlab("UMAP 2")

```

At this point, we have classified our porcine ileum organoid scRNA-seq dataset and been able to classify clusters into the following cell lineages:

* 'Prolific Stem/Prog'                (cluster 6) 
* 'Prolific TAC'                      (cluster 7) 
* 'TAC'                               (cluster 8, 9)
* 'Early EC Prog'                     (cluster 3)
* 'Late EC Prog'                      (cluster 13)
* 'Resting Cells'                     (cluster 11) 
* 'Undeveloped EC1'                   (cluster 1) 
* 'Undeveloped EC2'                   (cluster 4) 
* 'Renewing EC'                       (cluster 12)
* 'Secretory Lineage'                 (cluster 15)
* 'Developing EC'                     (cluster 0)
* 'Early Immature EC'                 (cluster 2)
* 'Late Immature EC'                  (cluster 5)
* 'Semi-Mature EC'                    (cluster 14)
* 'Migrating EC (Villous Tips)'))     (cluster 10) 


#################### Annotate/Heatmap/Dotplot of DGEs per cluster/cell type ####################


# Preliminary annotation
```{r, annotation plot, fig.height=4, fig.width=4.3, echo=FALSE}
#### Final annotations ####
bcs <- as.data.frame(colnames(sobj))
colnames(bcs) <- 'barcode'
bcs$cellID <- rep('_', nrow(bcs))
df <- as.data.frame(sobj$seurat_clusters)

# Cluster-based cell annotations
C6 <- rownames(subset(df, sobj$seurat_clusters %in% c("6")))
C7 <- rownames(subset(df, sobj$seurat_clusters %in% c("7")))
C8.9 <- rownames(subset(df, sobj$seurat_clusters %in% c("8", "9")))
C3 <- rownames(subset(df, sobj$seurat_clusters %in% c("3")))
C13 <- rownames(subset(df, sobj$seurat_clusters %in% c("13")))
C11 <- rownames(subset(df, sobj$seurat_clusters %in% c("11")))
C1.4 <- rownames(subset(df, sobj$seurat_clusters %in% c("1", "4")))
#C4 <- rownames(subset(df, sobj$seurat_clusters %in% c("4")))
C12 <- rownames(subset(df, sobj$seurat_clusters %in% c("12")))
C15 <- rownames(subset(df, sobj$seurat_clusters %in% c("15")))
C0 <- rownames(subset(df, sobj$seurat_clusters %in% c("0")))
C2 <- rownames(subset(df, sobj$seurat_clusters %in% c("2")))
C5 <- rownames(subset(df, sobj$seurat_clusters %in% c("5")))
C14 <- rownames(subset(df, sobj$seurat_clusters %in% c("14")))
C10 <- rownames(subset(df, sobj$seurat_clusters %in% c("10")))

# name the cells clusters (rename for ML)
bcs <- bcs %>% mutate(cellID = replace(cellID, barcode %in% C6, 'Prolific Stem/Prog')) 
bcs <- bcs %>% mutate(cellID = replace(cellID, barcode %in% C7, 'Prolific TAC'))
bcs <- bcs %>% mutate(cellID = replace(cellID, barcode %in% C8.9, 'TAC'))
bcs <- bcs %>% mutate(cellID = replace(cellID, barcode %in% C3, 'Early EC Prog'))
bcs <- bcs %>% mutate(cellID = replace(cellID, barcode %in% C13, 'Late EC Prog')) # MCM2-7+
bcs <- bcs %>% mutate(cellID = replace(cellID, barcode %in% C11, 'Resting Cells'))
bcs <- bcs %>% mutate(cellID = replace(cellID, barcode %in% C1.4, 'Undeveloped EC')) # 'Undeveloped EC1'
#bcs <- bcs %>% mutate(cellID = replace(cellID, barcode %in% C4, 'Undeveloped EC')) # 'Undeveloped EC2'
bcs <- bcs %>% mutate(cellID = replace(cellID, barcode %in% C12, 'Renewing EC')) 
bcs <- bcs %>% mutate(cellID = replace(cellID, barcode %in% C15, 'Secretory Lineage')) 
bcs <- bcs %>% mutate(cellID = replace(cellID, barcode %in% C0, 'Developing EC')) 
bcs <- bcs %>% mutate(cellID = replace(cellID, barcode %in% C2, 'Early Immature EC')) 
bcs <- bcs %>% mutate(cellID = replace(cellID, barcode %in% C5, 'Late Immature EC')) 
bcs <- bcs %>% mutate(cellID = replace(cellID, barcode %in% C14, 'Semi-Mature EC')) 
bcs <- bcs %>% mutate(cellID = replace(cellID, barcode %in% C10, 'Migrating EC (Villous Tips)')) # change name to 'Migrating Epithelial Cells (Villous Tips)' is forgotten

# update the metadatas slot
rownames(bcs) <- bcs$barcode
bcs$barcode <- NULL
sobj <- AddMetaData(sobj, metadata = bcs) # add new annotations to meta data slot

# plot new labeled cluster
DimPlot(sobj, 
        group.by = 'cellID', 
        reduction = 'umap', label = TRUE)
DimPlot(sobj, reduction = 'umap', label = FALSE, pt.size = 0.5, group.by = 'cellID', label.size = 3, label.box = "TRUE") + ggtitle(project_name, subtitle = paste("Epithelial Cells (n = ", paste(dim(sobj)[2], ")", sep = ""))) + ylab("UMAP 1") + xlab("UMAP 2") + NoLegend()

# Prolific Stem/Prog
DimPlot(sobj, 
        cells.highlight = C6, 
        cols.highlight = "blue", 
        sizes.highlight = 1,
        cols = "grey70", 
        order = TRUE, 
        reduction = 'umap') + ggtitle(project_name, subtitle = paste("Prolific Stem/Prog (n =", paste(length(C6), ")", sep = ""))) & NoAxes() & NoLegend()
# Prolific TA
DimPlot(sobj, 
        cells.highlight = C7, 
        cols.highlight = "blue", 
        sizes.highlight = 1,
        cols = "grey70", 
        order = TRUE, 
        reduction = 'umap') + ggtitle(project_name, subtitle = paste("Prolific TAC (n =", paste(length(C7), ")", sep = ""))) & NoAxes() & NoLegend()
# TA
DimPlot(sobj, 
        cells.highlight = C8.9, 
        cols.highlight = "blue", 
        sizes.highlight = 1,
        cols = "grey70", 
        order = TRUE, 
        reduction = 'umap') + ggtitle(project_name, subtitle = paste("TAC (n =", paste(length(C8.9), ")", sep = ""))) & NoAxes() & NoLegend()
# Early EC Prog
DimPlot(sobj, 
        cells.highlight = C3, 
        cols.highlight = "blue", 
        sizes.highlight = 1,
        cols = "grey70", 
        order = TRUE, 
        reduction = 'umap') + ggtitle(project_name, subtitle = paste("Early EC Prog (n =", paste(length(C3), ")", sep = ""))) & NoAxes() & NoLegend()
# Late EC Prog
DimPlot(sobj, 
        cells.highlight = C13, 
        cols.highlight = "blue", 
        sizes.highlight = 1,
        cols = "grey70", 
        order = TRUE, 
        reduction = 'umap') + ggtitle(project_name, subtitle = paste("Late EC Prog (n =", paste(length(C13), ")", sep = ""))) & NoAxes() & NoLegend()
# Resting Cells
DimPlot(sobj, 
        cells.highlight = C11, 
        cols.highlight = "blue", 
        sizes.highlight = 1,
        cols = "grey70", 
        order = TRUE, 
        reduction = 'umap') + ggtitle(project_name, subtitle = paste("Resting Cells (n =", paste(length(C11), ")", sep = ""))) & NoAxes() & NoLegend()
# Undeveloped EC
DimPlot(sobj, 
        cells.highlight = C1.4, 
        cols.highlight = "blue", 
        sizes.highlight = 1,
        cols = "grey70", 
        order = TRUE, 
        reduction = 'umap') + ggtitle(project_name, subtitle = paste("Undeveloped EC (n =", paste(length(C1.4), ")", sep = ""))) & NoAxes() & NoLegend()
# Undeveloped EC2
#DimPlot(sobj, 
#        cells.highlight = C4, 
#        cols.highlight = "blue", 
#        sizes.highlight = 1,
#        cols = "grey70", 
#        order = TRUE, 
#        reduction = 'umap') + ggtitle(project_name, subtitle = paste("Undeveloped EC2 (n =", paste(length(C4), ")", sep = ""))) & NoAxes() & NoLegend()
# Renewing EC
DimPlot(sobj, 
        cells.highlight = C12, 
        cols.highlight = "blue", 
        sizes.highlight = 1,
        cols = "grey70", 
        order = TRUE, 
        reduction = 'umap') + ggtitle(project_name, subtitle = paste("Renewing EC (n =", paste(length(C12), ")", sep = ""))) & NoAxes() & NoLegend()
# Secretory Lineage
DimPlot(sobj, 
        cells.highlight = C15, 
        cols.highlight = "blue", 
        sizes.highlight = 1,
        cols = "grey70", 
        order = TRUE, 
        reduction = 'umap') + ggtitle(project_name, subtitle = paste("Secretory Lineage (n =", paste(length(C15), ")", sep = ""))) & NoAxes() & NoLegend()
# Developing EC
DimPlot(sobj, 
        cells.highlight = C0, 
        cols.highlight = "blue", 
        sizes.highlight = 1,
        cols = "grey70", 
        order = TRUE, 
        reduction = 'umap') + ggtitle(project_name, subtitle = paste("Developing EC (n =", paste(length(C0), ")", sep = ""))) & NoAxes() & NoLegend()
# Early Immature EC
DimPlot(sobj, 
        cells.highlight = C2, 
        cols.highlight = "blue", 
        sizes.highlight = 1,
        cols = "grey70", 
        order = TRUE, 
        reduction = 'umap') + ggtitle(project_name, subtitle = paste("Early Immature EC (n =", paste(length(C2), ")", sep = ""))) & NoAxes() & NoLegend()
# Late Immature EC
DimPlot(sobj, 
        cells.highlight = C5, 
        cols.highlight = "blue", 
        sizes.highlight = 1,
        cols = "grey70", 
        order = TRUE, 
        reduction = 'umap') + ggtitle(project_name, subtitle = paste("Late Immature EC (n =", paste(length(C5), ")", sep = ""))) & NoAxes() & NoLegend()
# Semi-Mature EC
DimPlot(sobj, 
        cells.highlight = C14, 
        cols.highlight = "blue", 
        sizes.highlight = 1,
        cols = "grey70", 
        order = TRUE, 
        reduction = 'umap') + ggtitle(project_name, subtitle = paste("Semi-Mature EC (n =", paste(length(C14), ")", sep = ""))) & NoAxes() & NoLegend()
# Migrating EC (Villous Tips)
DimPlot(sobj, 
        cells.highlight = C10, 
        cols.highlight = "blue", 
        sizes.highlight = 1,
        cols = "grey70", 
        order = TRUE, 
        reduction = 'umap') + ggtitle(project_name, subtitle = paste("Migrating EC (Villous Tips) (n =", paste(length(C10), ")", sep = ""))) & NoAxes() & NoLegend()

# Initial Preliminary PLOT
DimPlot(sobj, reduction = 'umap', label = TRUE, pt.size = 0.1) + ggtitle(project_name, subtitle = paste("Preleminary Clustering (n = ", paste(dim(sobj)[2], ")", sep = ""))) + ylab("UMAP 1") + xlab("UMAP 2")
```

# In the chuck below, we plot the proportion of cell types
```{r cell proportion plot, fig.height=4, fig.width=8, echo=FALSE}
#### Cell type proportions calculations ####

# number of cells per cell type
l_c0 <- length(C0) 
l_c1.4 <- length(C1.4) 
l_c2 <- length(C2)
l_c3 <- length(C3)
#l_c4 <- length(C4)
l_c5 <- length(C5)
l_c6 <- length(C6)
l_c7 <- length(C7)
l_c8.9 <- length(C8.9)
l_c10 <- length(C10)
l_c11 <- length(C11)
l_c12<- length(C12)
l_c13 <- length(C13)
l_c14 <- length(C14)
l_c15 <- length(C15)

# make new lengths in case we want to add more cell types
#length(rownames(subset(df, sobj$cellID %in% c("Prolific Stem/Prog"))))

# Plotting all cell types
# making vectors in the order that we want to plot
cell_type.size <- c(l_c6, l_c7, l_c8.9, l_c3, l_c13, l_c15, l_c12, l_c0, l_c1.4, l_c2, l_c5, l_c10, l_c14, l_c11) # add l_c4 for Undeveloped EC2
cell_type.sum <- dim(sobj)[2]
cell_type.sum.leveled <- c('Prolific Stem/Prog', 'Prolific TAC', 'TAC', 'Early EC Prog', 'Late EC Prog', 'Secretory Lineage', 'Renewing EC', 'Developing EC', 'Undeveloped EC', 'Early Immature EC', 'Late Immature EC', 'Migrating EC (Villous Tips)', 'Semi-Mature EC', 'Resting Cells') # change Undeveloped EC to Undeveloped EC1 and add Undeveloped EC2 to the vector
# Making list and putting calculated proportion of cell types in it   # 
proportions_vec <- c() # make empty list to append in the loop below
for (i in 1:length(x = cell_type.size)) {  # we loop in range of sample_name, because that determine the number of replicates we have
  proportions <- cell_type.size[i] / cell_type.sum * 100
  proportions_vec <- c(proportions_vec, proportions)
}
# Make data frame of cell type proportions
data.proportions <- data.frame(cell_type.sum.leveled, proportions_vec)
data.proportions

# plot bars for cell type proportions
ggplot(data.proportions, aes(x = factor(cell_type.sum.leveled, levels = cell_type.sum.leveled), y = proportions_vec)) +
  geom_bar(stat = "identity", position = "dodge", alpha = 0.5, colour = "black", width = 0.8, fill="blue") + # position=position_dodge(.7) to distant two bars
  theme_bw() + 
  geom_text(aes(label = round(as.vector(data.proportions$proportions_vec), digits = 1)), position = position_dodge(width = 1),vjust = -0.5, size = 2.5) + # value above bar
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 8, colour = "black", )) + 
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) + 
  labs(x="Cell Type", y="Proportion (%)") + scale_fill_grey() +
  theme(aspect.ratio = 0.9) # + theme(legend.position = c(0.1, 0.75))

# Plotting summerzied cell types
cell_type.size <- c(l_c6, (l_c3 + l_c13), (l_c7 + l_c8.9), (l_c1.4 + l_c12 + l_c0 + l_c2 + l_c5 + l_c14 + l_c10), l_c15, l_c11)
cell_type.sum <- dim(sobj)[2]
cell_type.sum.leveled <- c('Prolific Stem/Prog', 'EC Prog', 'TAC', 'EC', 'Secretory Lineage', 'Resting Cells')
# Making list and putting calculated proportion of cell types in it
proportions_vec <- c() # make empty list to append in the loop below
for (i in 1:length(x = cell_type.size)) {  # we loop in range of sample_name, because that determine the number of replicates we have
  proportions <- cell_type.size[i] / cell_type.sum * 100
  proportions_vec <- c(proportions_vec, proportions)
}
# Make data frame of cell type proportions
data.proportions <- data.frame(cell_type.sum.leveled, proportions_vec)
data.proportions

# plot bars for cell type proportions
ggplot(data.proportions, aes(x = factor(cell_type.sum.leveled, levels = cell_type.sum.leveled), y = proportions_vec)) +
  geom_bar(stat = "identity", position = "dodge", alpha = 0.5, colour = "black", width = 0.8, fill="blue") + # position=position_dodge(.7) to distant two bars
  theme_bw() + 
  geom_text(aes(label = round(as.vector(data.proportions$proportions_vec), digits = 1)), position = position_dodge(width = 1),vjust = -0.5, size = 2.5) + # value above bar
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 8, colour = "black")) + 
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) + 
  labs(x="Cell Type", y="Proportion (%)") + scale_fill_grey() +
  theme(aspect.ratio = 0.9) # + theme(legend.position = c(0.1, 0.75))
```

# In the chuck below, we plot the proportion of cell types between tissue and organoid
```{r cell proportion plot, fig.height=4, fig.width=8, echo=FALSE}
#### Cell type proportions calculations ####

# Plotting summerzied cell types (FOR COMPARISON TO TISSUE)

# Make new proportions that includes the individual cells from the secretory lineage in organoid
C6 <- rownames(subset(df, sobj$cellID %in% c("Prolific Stem/Prog")))
C7 <- rownames(subset(df, sobj$cellID %in% c("Prolific TAC")))
C8.9 <- rownames(subset(df, sobj$cellID %in% c("TAC")))
C3 <- rownames(subset(df, sobj$cellID %in% c("Early EC Prog")))
C13 <- rownames(subset(df, sobj$cellID %in% c("Late EC Prog")))
C11 <- rownames(subset(df, sobj$cellID %in% c("Resting Cells")))
C1.4 <- rownames(subset(df, sobj$cellID %in% c("Undeveloped EC")))
#C4 <- rownames(subset(df, sobj$seurat_clusters %in% c("4")))
C12 <- rownames(subset(df, sobj$cellID %in% c("Renewing EC'")))
C15.1 <- rownames(subset(df, sobj$cellID %in% c("PC")))
C15.2 <- rownames(subset(df, sobj$cellID %in% c("GC")))
C15.3 <- rownames(subset(df, sobj$cellID %in% c("EEC")))
C0 <- rownames(subset(df, sobj$cellID %in% c("Developing EC")))
C2 <- rownames(subset(df, sobj$cellID %in% c("Early Immature EC")))
C5 <- rownames(subset(df, sobj$cellID %in% c("Late Immature EC")))
C14 <- rownames(subset(df, sobj$cellID %in% c("Semi-Mature EC")))
C10 <- rownames(subset(df, sobj$cellID %in% c("Migrating EC (Villous Tips)")))
# number of cells per cell type 
l_c0 <- length(C0) 
l_c1.4 <- length(C1.4) 
l_c2 <- length(C2)
l_c3 <- length(C3)
#l_c4 <- length(C4)
l_c5 <- length(C5)
l_c6 <- length(C6)
l_c7 <- length(C7)
l_c8.9 <- length(C8.9)
l_c10 <- length(C10)
l_c11 <- length(C11)
l_c12<- length(C12)
l_c13 <- length(C13)
l_c14 <- length(C14)
l_c15.1 <- length(C15.1)
l_c15.2 <- length(C15.2)
l_c15.3 <- length(C15.3)

# summarize
cell_type.size <- c(l_c6, (l_c3 + l_c13), (l_c7 + l_c8.9), (l_c1.4 + l_c12 + l_c0 + l_c2 + l_c5 + l_c14 + l_c10), l_c15.1, l_c15.2, l_c15.3, l_c11)
cell_type.sum <- dim(sobj)[2]
cell_type.sum.leveled <- c('Prolific Stem/Prog', 'EC Prog', 'TAC', 'EC', 'PC', 'GC', 'EEC', 'Resting Cells')
# Making list and putting calculated proportion of cell types in it
proportions_vec <- c() # make empty list to append in the loop below
for (i in 1:length(x = cell_type.size)) {  # we loop in range of sample_name, because that determine the number of replicates we have
  proportions <- cell_type.size[i] / cell_type.sum * 100
  proportions_vec <- c(proportions_vec, proportions)
}
# Make data frame of cell type proportions
data.proportions <- data.frame(cell_type.sum.leveled, proportions_vec)
data.proportions

###### HERE WE IMPORT THE PROPORTIONS OF ILEUM TISSUE AND COMPARE TO ILEUM ORG ######
###### THIS SNIPPED OF CODE WILL NOT WORK IS DATA IS NOT IMPORTED CORRECTLY ######

# For each list of cell type proportions, we add the cell origin (i.e. Organoid or Tissue)
data.proportions$origin[1:length(rownames(data.proportions))] <- "Organoid"
data.proportions.tiss$origin[1:length(rownames(data.proportions.tiss))] <- "Tissue"

# make backup (temp)
data.proportions.backup <- data.proportions
data.proportions.tiss.backup <- data.proportions.tiss

data.proportions
data.proportions.tiss

# Append the cell types of organoid to tissue
new_row1 = c(cell_type.sum.leveled = "TAC", proportions_vec = 0, origin = "Tissue")
new_row2 = c(cell_type.sum.leveled = "Resting Cells", proportions_vec = 0, origin = "Tissue")
data.proportions.tiss = rbind(data.proportions.tiss,new_row1)
data.proportions.tiss = rbind(data.proportions.tiss,new_row2)

# Append the cell types of tissue to organoid
new_row1 = c(cell_type.sum.leveled = "Endothelium", proportions_vec = 0, origin = "Organoid")
new_row2 = c(cell_type.sum.leveled = "Mesenchyme", proportions_vec = 0, origin = "Organoid")
new_row3 = c(cell_type.sum.leveled = "TC", proportions_vec = 0, origin = "Organoid")
data.proportions = rbind(data.proportions, new_row1)
data.proportions = rbind(data.proportions, new_row2)
data.proportions = rbind(data.proportions, new_row3)

# Make the "proportions_vec" column as numerical
#data.proportions$proportions_vec <- as.numeric(data.proportions$proportions_vec) 
#data.proportions.tiss$proportions_vec <- as.numeric(data.proportions.tiss$proportions_vec) 

# Now we append them within each other and sort
merged.proportions <- rbind(data.proportions, data.proportions.tiss)
merged.proportions <- merged.proportions[order(merged.proportions$cell_type.sum.leveled, decreasing = TRUE), ]
merged.proportions$proportions_vec <- as.numeric(merged.proportions$proportions_vec) # Make the "proportions_vec" column as numerical

merged.proportions

# Level the order
leveled <- c('Prolific Stem/Prog', 'EC Prog', 'TAC', 'EC', 'PC', 'GC', 'EEC', 'TC', "Mesenchyme", "Endothelium", 'Resting Cells')

# plot bars for cell type proportions
ggplot(merged.proportions, aes(x = factor(cell_type.sum.leveled, levels = leveled), y = proportions_vec, fill = origin)) +
  geom_bar(stat = "identity", position = "dodge", alpha = 0.7, colour = "black", width = 0.8) + 
  theme_bw() + 
  geom_text(aes(label = round(as.vector(merged.proportions$proportions_vec), digits = 1)), position = position_dodge(width = 1),vjust = -0.5, size = 2.5) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 12, colour = "black")) + 
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) + 
  labs(x="Cell Type", y="Relative Proportion (%)") + scale_fill_grey() +
  theme(aspect.ratio = 0.7) # + theme(legend.position = c(0.1, 0.75))
```



#################### Cell cycle analysis of cluster/cell type ####################


# In the chuck below we will look at cell cycle genes per cluster based on cell cylce score
# Cell cycle estimate cell cycle phase of each cell and make a table to describe how many cells per phase.
```{r cell-cycle, fig.height=3, fig.width=3.5, echo=FALSE}
# As the s.genes/g2m.genes have been written for Human, we are supposed to change the organism here, i.e., we need to align all genes in Pig. 
convertHumanGeneList <- function(x){
  require("biomaRt")
  human = useMart("ensembl", dataset = "hsapiens_gene_ensembl", host = "https://feb2021.archive.ensembl.org/") # oct 2022 is latest
  pig = useMart("ensembl", dataset = "sscrofa_gene_ensembl", host = "https://feb2021.archive.ensembl.org/")
  genesV2 = getLDS(attributes = c("hgnc_symbol"), 
                   filters = "hgnc_symbol", 
                   values = x , 
                   mart = human,
                   attributesL = c("hgnc_symbol"), 
                   martL = pig, uniqueRows=T)
  humanx <- unique(genesV2[, 2])
  return(humanx)}
# save the genes
s_gene <- convertHumanGeneList(cc.genes$s.genes)
g2m_gene <- convertHumanGeneList(cc.genes$g2m.genes)
# Calculate the cellcycle score and plot
sobj <- CellCycleScoring(sobj, s.features = s_gene, g2m.features = g2m_gene, set.ident = TRUE)
DimPlot(sobj, reduction = "umap", pt.size = 0.5, group.by = 'Phase', cols = c('S' = 'orange', 'G2M' = 'darkgreen', 'G1' = 'red')) + ggtitle(project_name, subtitle = "Cell Cycle") + ylab("UMAP 1") + xlab("UMAP 2")
table(sobj@meta.data$Phase)
#cols.highlight = c("red","yellow","blue","green","darkorchid","orange","grey0","deeppink","gold4","darkgreen")
```


#################### Annotation of Secretory Lineage ####################


# In the chuck below we will more spcifically focus on the secretory cluster than contains more than only Goblet sells (i.e. endocrine and Penth) 
# Based on studying the the tissue (from ours samples and Wiarda et al., 2023) we further annotate the secretory cluster in 3 distinct cell types based on marker genes and remaining cell stay as previous labeling.
```{r improve secretory annotation, fig.height=4, fig.width=4, echo=FALSE}
Idents(sobj) <- "cellID" # Set the ident of the metadata to the one of interest (in this case our cellIDs)
# showing cell types within annotated secretory cluster 
FeaturePlot(sobj[,sobj$cellID == "Secretory Lineage"], features = c("NEUROG3", "NEUROD1", "PAX4", "CHGA", "LYZ", "RETNLB", "XBP1", "MUC2"),cols = c("grey", "red"),  pt.size = 1, reduction = "umap", label = FALSE) + ylab("UMAP 1") + xlab("UMAP 2") 

FeaturePlot(sobj[,sobj$cellID == "Secretory Lineage"], features = c("MUC2", "CLCA1", "REG4", "TFF3"),cols = c("grey", "red"),  pt.size = 1, reduction = "umap", label = FALSE) + ylab("UMAP 1") + xlab("UMAP 2") 

FeaturePlot(sobj[,sobj$cellID == "Secretory Lineage"], features = c("SOX9", "HMGB2", "TPX2", "UBE2C", "TOP2A", "BNIP3"),cols = c("grey", "red"),  pt.size = 1, reduction = "umap", label = FALSE) + ylab("UMAP 1") + xlab("UMAP 2") 

FeaturePlot(sobj, features = c("SOX9", "HMGB2", "TPX2", "UBE2C", "TOP2A", "BNIP3"),cols = c("grey", "red"),  pt.size = 1, reduction = "umap", label = FALSE) + ylab("UMAP 1") + xlab("UMAP 2")

FeaturePlot(sobj[,sobj$cellID == "Secretory Lineage"], features = c("C3", "CA8"),cols = c("grey", "red"),  pt.size = 1, reduction = "umap", label = FALSE) + ylab("UMAP 1") + xlab("UMAP 2")

FeaturePlot(sobj[,sobj$cellID == "Secretory Lineage"], features = c("MUC2", "EPHB2", "EPHB3", "LYZ", "REG4", "SOX9", "RETNLB", "FCN2", "HES6", "DEFB1", "PCNA"),cols = c("grey", "red"),  pt.size = 0.5, reduction = "umap", label = FALSE) + ylab("UMAP 1") + xlab("UMAP 2")


#######   OLD METHOD   #############

# Paneth (with unqie markers)
#WhichCells(sobj[,sobj$cellID == "Secretory Lineage"], expression = C3 & SPINK1 & LYZ & RETNLB > 0 )
#WhichCells(sobj[,sobj$cellID == "Secretory Lineage"], expression = C3 & RETNLB & RETNLB & FCN2 > 0 )
#WhichCells(sobj[,sobj$cellID == "Secretory Lineage"], expression = CA8 > 0 )
#WhichCells(sobj[,sobj$cellID == "Secretory Lineage"], expression = EPHB3 > 0 )

#paneth <- c("CTCCTTTGTAGGGAGG-1_1", "TCACTCGGTGTTACTG-1_1", "ACCTGAAAGCATTTCG-1_2", "AGACAAACAATACCTG-1_2", "CGGGCATCAGGCGATA-1_2", "TTACAGGAGGAAGAAC-1_2", "GATCACAAGAGGTGCT-1_1", "TCACGCTCATCCGAAT-1_1")
#("GTTCATTGTCCGAAAG-1_2", "CTCCCTCCAGATCCTA-1_1", "CGGGTGTTCTTCTAAC-1_2", "TACCTGCAGCCTCCAG-1_2") # These do not cluster with paneth in tissue

# Endocrine (with unique markers)
#WhichCells(sobj[,sobj$cellID == "Secretory Lineage"], expression = CHGA | NEUROD1 | NEUROG3 | PAX4 > 0)
#endoc <- c("CCCTCAATCCGATCGG-1_1", "GGATCTAAGTCGGCAA-1_1", "ACACGCGTCCACAAGT-1_2", "GCCGATGGTTCACGAT-1_2", "TCCGAAATCTACCACC-1_2")


# Goblet (overlaps with paneth will be removed)
#WhichCells(sobj[,sobj$cellID == "Secretory Lineage"], expression = MUC2 & TFF3 & SPINK4 & REG4 & CLCA1 > 0)
#WhichCells(sobj[,sobj$cellID == "Secretory Lineage"], expression = TCN1 > 0)
#WhichCells(sobj[,sobj$cellID == "Secretory Lineage"], expression = MUC2 > 0)
#WhichCells(sobj[,sobj$cellID == "Secretory Lineage"], expression = CLCA1 > 0)
#gobl <- c("ACTATGGCAGTGGTGA-1_1", "ATTATCCTCTAGGCCG-1_1", "ATTCCTAAGAAGTCTA-1_1", "CCACGTTTCCGATGCG-1_1", "CCGATGGCATGGCGCT-1_1", "CTTCTAAAGGATGGCT-1_1", "AGCGCCATCCTACGGG-1_2", "AGCGTATTCGTTTACT-1_2", "CAACCAAGTACCGGAA-1_2", "CCACACTAGCCGTTGC-1_2", "GCTTTCGAGGCCTAAG-1_2", "TAACCAGTCAGGAACG-1_2", "TCAGTTTGTCAATGGG-1_2", "TCAAGACCAGTAACGG-1_1", "CAAGAGGGTGAATGAT-1_1", "TGTCAGATCAAATGAG-1_1", "CCGGTAGAGAAGCGAA-1_2", "ATGCGATCACTCCACT-1_1", "AAGTTCGGTAAGAACT-1_2", "CAGATCACAAGGTACG-1_2", "GATAGAAGTCGTCGGT-1_2", "TGCACGGTCATGACAC-1_2", "TGGATCATCGCATAGT-1_1", "GCAGTTACACCAGTAT-1_1", "CCGATGGCAGTCACGC-1_1", "CTCCACACAAAGCAAT-1_1", "CTGCCTAAGTTGAATG-1_1")
#("ACGTCCTAGCACCTGC-1_1", "CTTCAATCAGGAGACT-1_2", "TCACGGGAGTCCCAGC-1_2", "TCGTAGAAGACTTCAC-1_2") # THese are not Goblet when compared to tissue


#######   NEW METHOD   #############


# Take Paneth cells
pan1 <- WhichCells(sobj[,sobj$cellID == "Secretory Lineage"], expression = RETNLB > 0 & FCN2 > 0)
pan2 <- WhichCells(sobj[,sobj$cellID == "Secretory Lineage"], expression = SOX9 > 0)
pan.combined <- c(pan1, pan2) # combine
pan.unique <- unique(pan.combined) # and keep remove duplicates
# Take Goblet cells that are NOT Paneth (since MUC2 appears not to be Goblet specific in Pig (see literature), we consider MUC2+ cells lacking Paneth signature as Goblet
gob1 <- WhichCells(sobj[,sobj$cellID == "Secretory Lineage"], expression = MUC2 > 0 & TFF3 > 0)
gob.unique <-  gob1[is.na(match(gob1,pan.unique))] # Find cells that are not in Paneth
# Take Enteroendocrine
EEC.unique <- WhichCells(sobj[,sobj$cellID == "Secretory Lineage"], expression = CHGA  > 0 | NEUROD1 > 0  | NEUROG3 > 0  | PAX4 > 0)
# Take secretory progenitor that are not in PC, BC and EEC
prog <- WhichCells(sobj[,sobj$cellID == "Secretory Lineage"], expression = MKI67 | TK1 | TOP2A | PLK1 | CCNB1 | HMGB2 | TPX2 | H2AC6 | H2AC4 | H2AC20 | CENPF | CDC20 | NUSAP1 | UBE2C > 0)
prog.unique.in.pan <- prog[is.na(match(prog, pan.unique))] # keep ones that are not in paneth
prog.unique.in.gob <- prog.unique.in.pan[is.na(match(prog.unique.in.pan, gob.unique))] # keep ones that are not in goblet
prog.unique.in.EEC <- prog.unique.in.gob[is.na(match(prog.unique.in.gob, EEC.unique))] # keep ones that are not in EEC
prog.unique <- as.vector(na.omit(prog.unique.in.EEC)) # keep unique and remove NA

# number of secretory cells
length(gob.unique)
(length(pan.unique) + length(prog.unique))
length(EEC.unique) 
#Proportio relative to secretory lineage abundance
length(gob.unique) / 4860 * 100
(length(pan.unique) + length(prog.unique)) / 4860 * 100
length(EEC.unique) / 4860 * 100

# Adjusting the annotation of some secretory cells in the Ident slot
Idents(sobj, cells = pan.unique) <- "PC"
Idents(sobj, cells = gob.unique) <- "GC" 
Idents(sobj, cells = EEC.unique) <- "EEC"
Idents(sobj, cells = prog.unique) <- "PC" # change to PC in case it's a paneth

# adjusting the names in the remaining slots (metadata and sobj$cellid)
# Finding the positions of the cell types
PC.pos <- c(match(c(paste(pan.unique)), rownames(sobj@meta.data)))
GC.pos <- c(match(c(paste(gob.unique)), rownames(sobj@meta.data)))
EEC.pos <- c(match(c(paste(EEC.unique)), rownames(sobj@meta.data)))
prog.pos <- c(match(c(paste(prog.unique)), rownames(sobj@meta.data)))

# Find position/index of all cell in the "secretory cluster"
secr.cells.pos <- which(sobj@meta.data[["cellID"]] == "Secretory Lineage")
secr.cells <- sobj@meta.data[["cellID"]][c(secr.cells.pos)]

# replace the name of that gene celltype
sobj@meta.data[["cellID"]][PC.pos] <- c(paste("PC")) 
sobj@meta.data[["cellID"]][GC.pos] <- c(paste("GC")) 
sobj@meta.data[["cellID"]][EEC.pos] <- c(paste("EEC")) 
sobj@meta.data[["cellID"]][prog.pos] <- c(paste("PC")) # change to PC in case it's a paneth
# change remaining cell (far from secretory lineage cluster) to goblet
sobj@meta.data[["cellID"]][which(sobj@meta.data[["cellID"]] == "Secretory Lineage")] <- c(paste("GC")) # its position 480

# Plot the final cluster for annotation
DimPlot(sobj, reduction = 'umap', label = F, pt.size = 0.3, repel = T, ) + ggtitle(project_name, subtitle = paste("Preleminary Clustering (n = ", paste(dim(sobj)[2], ")", sep = ""))) + ylab("UMAP 1") + xlab("UMAP 2") + NoLegend()

# Plot the secretory lineage
DimPlot(sobj[,sobj$cellID == "GC" | sobj$cellID == "PC" | sobj$cellID == "EEC"], group.by = 'cellID', pt.size = 0.8, cols = c('GC' = 'green', 'PC' = 'gold2', "EEC" = "cyan"))
```


#################### Monocle trajectory ####################


```{r trjectory, fig.height=5, fig.width=6, echo=FALSE} 
# 5, 6 for umap
# 6, 2 for trajectory gene plot

####### STEP 1: obtaining the required formats from our Seurat object ####### 
Idents(sobj) <- "cellID" # Set the ident of the metadata to the one of interest (in this case our cellIDs)
# Monocle3 requires cell_data_set object
# So we convert seurat object to cell_data_set object for monocle3
cds.obj <- as.cell_data_set(sobj)
# Now we need cell Metadata for monocle3
colData(cds.obj)
# next is gene count matrix for monocle3
fData(cds.obj)$gene_short_name <- rownames(fData(cds.obj)) # add gene names as column to fData(cds.obj)
counts(cds.obj) # this is the count matrix
  
#######  Step 2: Cluster cells using the clustering info from our Seurat's UMAP) ####### 

# We are going to use the clustering information we have
# assign partitions
reacreate.partition <- c(rep(1,length(cds.obj@colData@rownames)))
names(reacreate.partition) <- cds.obj@colData@rownames
reacreate.partition <- as.factor(reacreate.partition)

cds.obj@clusters$UMAP$partitions <- reacreate.partition

# Assign the cluster info from Seurat to Monocle cell_data_set
sobj <- SetIdent(sobj, value = "cellID") # Change the ident of the cluster to cell-type or any other ID of interest
list_cluster <- sobj@active.ident

cds.obj@clusters$UMAP$clusters <- list_cluster
# Assign UMAP coordinate from our Seurat object to the Monocle cell_data_set
cds.obj@int_colData@listData$reducedDims$UMAP <- sobj@reductions$umap@cell.embeddings

# Correct counts for cds.obj sobj to Counts/geometric_mean(total_Counts)
# cds.obj <- as.cell_data_set(sobj, assay = "RNA") # Seurat Wrappers funtion
cds.obj <- estimate_size_factors(cds.obj) #  Monocle3 function

# plot normal annotated cluster in Monocle3 befroe trajection
pre.trajectory.cluster <- plot_cells(cds.obj,
           color_cells_by = "cluster",
           label_groups_by_cluster = FALSE,
           group_label_size = 0, cell_size = 0.8) + scale_color_manual(values = c('blue', 'green', 'maroon', 'yellow', "red", 'grey', 'cyan', "darkorchid", "orange", "deeppink2", "gold4", "darkgreen", "magenta", "green3", "black", "brown", "magenta", "red4")) + theme(legend.position = "right")
pre.trajectory.cluster

# Now we will run the learning Algorithm in Monocle to trajectory
# We do not use partitions, because we all cells are connected as the organoid is relatively of low-complexity
cds.obj <- learn_graph(cds.obj, use_partition = FALSE, learn_graph_control=list(ncenter=2200), close_loop = F) # 1500 (is optional), 2200 is final
#RGE_method = 'SimplePPT'

# Visualize cluster an interjection 
plot_cells(cds.obj,
           color_cells_by = 'cluster',
           label_groups_by_cluster = FALSE,
           label_branch_points = FALSE,
           label_roots = FALSE,
           label_leaves = FALSE,
           group_label_size = 0,
           trajectory_graph_segment_size = 1.1, 
           trajectory_graph_color = "red") + ggtitle(project_name, subtitle = paste("Trajectory Inference")) + ylab("UMAP 1") + xlab("UMAP 2")

# Select starting points based based on expectation, In this case the Stem/Prog in G2 phase
cds.obj <- order_cells(cds.obj)

### Or make additional plots for manual starting node
# plot the graph with pseudotime junctions and name of the junctions
plot_cells(
  cds = cds.obj,
  color_cells_by = "cellID",
  show_trajectory_graph = TRUE,
  label_principal_points = TRUE
) 
# Manually picking starting node
# Get the user starting node of choice and order the cells
starting.node.of.choice <- 'Y_49' # get this from the plot above
cds.obj <- order_cells(cds.obj, root_pr_nodes = starting.node.of.choice)

# Plot Pseudotime
plot_cells(cds.obj,
           color_cells_by = 'pseudotime',
           label_groups_by_cluster = FALSE,
           label_branch_points = FALSE,
           label_roots = FALSE,
           label_leaves = FALSE,
           group_label_size = 0,
           trajectory_graph_segment_size = 1.2, cell_size = 1.2,
           trajectory_graph_color = "red") + ggtitle(project_name, subtitle = paste("Trajectory Inference")) + ylab("UMAP 1") + xlab("UMAP 2")

# Add out pseudotime to seurat object metadata that we will later use for co-expression module dynamics with pseudotime
sobj$pseudotime <- pseudotime(cds.obj)
sobj@meta.data # check if added and sorted correclty (stem cells must be lower values)
pseudotime <- pseudotime(cds.obj)
saveRDS(pseudotime, file = "pseudotime.Ileum.Organoid.rds")

# cells ordered by pseudotime in barplot
pseudotime(cds.obj) # cell based on pseudotime
cds.obj$monocle3_pseudotime <- pseudotime(cds.obj)
data.pseudo <- as.data.frame(colData(cds.obj))
ggplot(data.pseudo, aes(monocle3_pseudotime, reorder(cellID, monocle3_pseudotime, median))) + 
  geom_boxplot() + 
  theme_bw() +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
  labs(x="Pseudotime", y="")

# Now lets find genes that change as a function of pseudotime using genes that are differentially expressed on the different paths through the trajectory.
# We test whether cells at similar positions on the trajectory have correlated expression using Moran's statistics.
# Moran's statistics finds correlation coefficient that measures the overall spatial autocorrelation in the data set. It measures how one object is similar to others surrounding it.
cds.obj_DEG <- graph_test(cds.obj, neighbor_graph="principal_graph", cores=6, method = c("Moran_I")) # Be careful with the number of cores selected, it literally SHITS on your computer! (slower with ARM64, so use X86 or Rosseta if using AMR64 Apple Computer) 
cds.obj_DEG
# Filter the DEG object based on passed test and P<0.05 
cds.obj_DEG <- na.omit(cds.obj_DEG)
cds.obj_DEG <- cds.obj_DEG[cds.obj_DEG$p_value < 0.05 & cds.obj_DEG$status == "OK", ]
cds.obj_DEG
# Sort based on morans_test_statistic
cds.obj_DEG[order(-cds.obj_DEG$morans_test_statistic),] 

# Some test code
plot_cells(cds.obj, genes=c("ATOH1", "SPDEF", "GFI1", "NOTCH1", "NOTCH4", "DLL1", "DLL2", "DLL4"),
           show_trajectory_graph=FALSE,
           label_cell_groups=FALSE,
           label_leaves=FALSE,)

# Plot gene expression of interest as function of trajection subset
# We start with checking how stem/prog cells develop to villus tips (epithelium)
Stem_to_tip_lineage_cells <- c('Prolific Stem/Prog', 'Prolific TAC', 'Early EC Prog', 'Late EC Prog', 'Secretory Lineage', 'Renewing EC', 'Developing EC', 'Early Immature EC', 'Late Immature EC', 'Migrating EC (Villous Tips)', 'Semi-Mature EC')
# Or 
Stem_to_tip_lineage_cells <- c('Prolific Stem/Prog', 'Prolific TAC', 'Early EC Prog', 'Late EC Prog', 'PC', 'GC', 'EEC', 'Renewing EC', 'Developing EC', 'Early Immature EC', 'Late Immature EC', 'Migrating EC (Villous Tips)', 'Semi-Mature EC')
# Genes to be analyzed in pseudotime
stem.prog_genes <- c("MKI67", "TK1", "TOP2A", "HMGB2", "CENPF", "CDC20", "UBE2C")
epithel.devl_genes <- c("ACTB", "PLS1", "VIL1" ,"EPS8", "EZR", "MYO6", "MYO5B")
villus.tip_genes <- c("LAMA3" , "CDH1", "LGALS3", "LGALS1", "MMP7", "MMP13", "MSN")
nut.abs_genes <- c("FABP2","APOA4", "ACE2", "SI", "SLC5A1")
nut.abs_genes2 <- c("SLC5A1", "SLC7A9", "SLC26A6", "SLC13A1", "SLC39A5", "FABP1", "RBP2")

# Stem
Stem_to_tip_lineage_cds <- cds.obj[rowData(cds.obj)$gene_short_name %in% stem.prog_genes, colData(cds.obj)$cellID %in% Stem_to_tip_lineage_cells]
plot_genes_in_pseudotime(Stem_to_tip_lineage_cds,
                         color_cells_by="cellID", min_expr = 0, cell_size = 0.2) + NoLegend()
# Epithelial development
Stem_to_tip_lineage_cds <- cds.obj[rowData(cds.obj)$gene_short_name %in% epithel.devl_genes, colData(cds.obj)$cellID %in% Stem_to_tip_lineage_cells]
plot_genes_in_pseudotime(Stem_to_tip_lineage_cds,
                         color_cells_by="cellID", min_expr = 0, cell_size = 0.2) + NoLegend()
# Migration (villus tips)
Stem_to_tip_lineage_cds <- cds.obj[rowData(cds.obj)$gene_short_name %in% villus.tip_genes, colData(cds.obj)$cellID %in% Stem_to_tip_lineage_cells]
plot_genes_in_pseudotime(Stem_to_tip_lineage_cds,
                         color_cells_by="cellID", min_expr = 0, cell_size = 0.2) + NoLegend()
# Nutrition absorptive genes
Stem_to_tip_lineage_cds <- cds.obj[rowData(cds.obj)$gene_short_name %in% nut.abs_genes, colData(cds.obj)$cellID %in% Stem_to_tip_lineage_cells]
plot_genes_in_pseudotime(Stem_to_tip_lineage_cds,
                         color_cells_by="cellID", min_expr = 0.2, cell_size = 0.2) + NoLegend()
# Nutrition absorptive genes (expressed in org)
Stem_to_tip_lineage_cds <- cds.obj[rowData(cds.obj)$gene_short_name %in% nut.abs_genes2, colData(cds.obj)$cellID %in% Stem_to_tip_lineage_cells]
plot_genes_in_pseudotime(Stem_to_tip_lineage_cds,
                         color_cells_by="cellID", min_expr = 0.2, cell_size = 0.2) + NoLegend()

# To load the transcription factors we previously found in tissue as function of pseudotime
# This will be directly added to the data tab in R
load(file="/Users/hamid/Desktop/ABG MSc project/Raw data/Ileum tissue/Wiarda - Ileum Tissue (non-immune)/WGCNA/Hub TFs/Hub_Transcription_Factors")
TF.per.module
# Transcription factors from tissue
Stem_to_tip_lineage_cds <- cds.obj[rowData(cds.obj)$gene_short_name %in% TF.per.module[[2]]$Symbol, colData(cds.obj)$cellID %in% Stem_to_tip_lineage_cells]
plot_genes_in_pseudotime(Stem_to_tip_lineage_cds,
                         color_cells_by="cellID", min_expr = 0.2, cell_size = 0.2)

# cells ordered by pseudotime for the given subset
pseudotime(Stem_to_tip_lineage_cds) # cell based on pseudotime
Stem_to_tip_lineage_cds$monocle3_pseudotime <- pseudotime(Stem_to_tip_lineage_cds)
data.pseudo <- as.data.frame(colData(Stem_to_tip_lineage_cds))
ggplot(data.pseudo, aes(monocle3_pseudotime, reorder(cellID, monocle3_pseudotime, median))) + 
  geom_boxplot() + 
  theme_bw() +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
  labs(x="Pseudotime", y="")

# Plot Pseudotime of Stem_to_tip
Stem_to_tip_cds <- cds.obj[, colData(cds.obj)$cellID %in% Stem_to_tip_lineage_cells] # subset the cds
# pseudotime
plot_cells(Stem_to_tip_cds,
           color_cells_by = 'pseudotime',
           label_groups_by_cluster = FALSE,
           label_branch_points = FALSE,
           label_roots = FALSE,
           label_leaves = FALSE,
           group_label_size = 0,
           trajectory_graph_segment_size = 0, cell_size = 1.2,
           trajectory_graph_color = "red") + ggtitle(project_name, subtitle = paste("Trajectory Inference")) + ylab("UMAP 1") + xlab("UMAP 2")
# Celltype
plot_cells(Stem_to_tip_cds,
           color_cells_by = 'cellID',
           label_groups_by_cluster = FALSE,
           label_branch_points = FALSE,
           label_roots = FALSE,
           label_leaves = FALSE,
           group_label_size = 0,
           trajectory_graph_segment_size = 0, cell_size = 1.2,
           trajectory_graph_color = "red") + ggtitle(project_name, subtitle = paste("Trajectory Inference")) + ylab("UMAP 1") + xlab("UMAP 2")

# TESTING STUFF
# Plot the three pseudoteporal trajectories

# Separate pseudotime trajectories by the different mature cells
# For Stem to Enterocytes
sobj$EC_pseudotime <- ifelse(sobj$cellID %in% c('Prolific Stem/Prog', 'Prolific TAC', 'Early EC Prog', 'Late EC Prog', 'PC', 'GC', 'EEC', 'Renewing EC', 'Developing EC', 'Early Immature EC', 'Late Immature EC', 'Migrating EC (Villous Tips)', 'Semi-Mature EC'), sobj$pseudotime, NA)
# Stem to undeveloped EC
sobj$IEC_pseudotime <- ifelse(sobj$cellID %in% c('Prolific Stem/Prog', 'Prolific TAC', 'Early EC Prog', 'Late EC Prog', 'TAC', 'Undeveloped EC', 'Resting Cells'), sobj$pseudotime, NA)
# From stem to secretory cells
sobj$SEC_pseudotime <- ifelse(sobj$cellID %in% c('Prolific Stem/Prog', 'Prolific TAC', 'Early EC Prog', 'Late EC Prog', 'Developing EC', 'PC', 'GC', 'EEC', 'Renewing EC'), sobj$pseudotime, NA)

# Make the plotting:
# Find the coordinates of the UMAP from the clustering
sobj$UMAP1 <- sobj@reductions$umap@cell.embeddings[,1]
sobj$UMAP2 <- sobj@reductions$umap@cell.embeddings[,2]

# PLot EC 
p1 <- sobj@meta.data %>%
  ggplot(aes(x=UMAP1, y=UMAP2, color=EC_pseudotime)) +
  ggrastr::rasterise(geom_point(size=1), dpi=700, scale=0.75) +
  coord_equal() +
  scale_color_gradientn(colors=plasma(256), na.value='grey') +
  umap_theme() 
p2 <- sobj@meta.data %>%
  ggplot(aes(x=UMAP1, y=UMAP2, color=IEC_pseudotime)) +
  ggrastr::rasterise(geom_point(size=1), dpi=700, scale=0.75) +
  coord_equal() +
  scale_color_gradientn(colors=viridis(256), na.value='grey') +
  umap_theme()
# Plot SEC
p3 <- sobj@meta.data %>%
  ggplot(aes(x=UMAP1, y=UMAP2, color=SEC_pseudotime)) +
  ggrastr::rasterise(geom_point(size=1), dpi=700, scale=0.75) +
  coord_equal() +
  scale_color_gradientn(colors=mako(256), na.value='grey') +
  umap_theme()
# Print plots
print(p1)
print(p2)
print(p3)
```

# In the chuck below we make heatmap of new annotated data
```{r clusterHeatmap-MT, fig.height=9, fig.width=14, echo=FALSE}
Idents(sobj) <- "cellID" # Set the ident of the metadata to the one of interest (in this case our cellIDs)

# Make a vector of all relevant markers
DGE_genes <- c("MKI67", "TK1", 'TOP2A', 'PLK1', "CCNB1", "HMGB2", "TPX2", "H2AC6" ,"H2AC4", "H2AC20", "CDK1", "CDK4", "CDK6", "CENPF", "CDC20", "NUSAP1", "UBE2C", "ARID1A", "MSH6", "POLA1", "CDT1", "MCM2", "MCM4", "MCM5", "MCM6", "MCM7", "HES1", "ELF3", "GADD45GIP1", "TGFBR2", "CDHR2", "CDHR5", 'HNF4A', 'HNF4G', 'NR5A2', "ACTB", "PLS1", "VIL1" ,"EPS8", "EZR", "MYO6", "MYO1A", "MYO1B", 'MYO5B', "MYO7B", "USH1C", 'BAIAP2L1', "KRT8", "KRT18", "KRT19", "KRT20", "DNMT", "CDH17", "EPCAM", "ANXA13", "SDCBP2", "EMP1", "FABP1", "SLC39A5", "ALDOC", "SLC11A2",  'LAMA3', 'CDH1', 'LGALS3', "LGALS1", "MSN" ,"MMP7", "MMP13", "HES6", "ATOH1", "TFF3", "SPINK4", "REG4", "MUC2", 'LYZ', 'RETNLB', 'FCN2', "SOX9", "NEUROG3", "NEUROD1", "PAX4", "CHGA") 

# level the cellIDs by personal preference
sobj$cellID <- factor(sobj$cellID, levels = c('Prolific Stem/Prog', 'Prolific TAC', 'TAC', 'Early EC Prog', 'Late EC Prog', "PC", "GC", "EEC", 'Renewing EC', 'Developing EC', 'Undeveloped EC', 'Early Immature EC', 'Late Immature EC', 'Migrating EC (Villous Tips)', 'Semi-Mature EC', 'Resting Cells')) # Undeveloped EC2 removed

# Make heatmap of DGEs
DoHeatmap(subset(sobj, downsample = 200), features = DGE_genes, assay = "RNA", label = FALSE, group.by = 'cellID') + scale_fill_gradientn(colors = c("darkturquoise", "grey90", "red")) + 
  theme(axis.text.y = element_text(face = 'italic')) #+ NoLegend()

# Make Violinplot of RNA count, and MT
VlnPlot(sobj, features = c("nCount_RNA"), pt.size = 0.5, group.by = 'cellID')
VlnPlot(sobj, features = c("nFeature_RNA"), pt.size = 0.5, group.by = 'cellID')

# Build a phylogenetic tree, utilizing seurat_clusters as our groups and using the pre-determined significant number of PCs to specify the dimensionality of our data to use:
sobj <- SetIdent(sobj, value = sobj@meta.data$cellID) # set active ident to names of cluster 
phylogenetic <- BuildClusterTree(sobj, 
                       dims = pc.dims, 
                       assay = "PCA")
PlotClusterTree(phylogenetic, edge.width = 3) # plot tree with node labels
# Let's remove node labels and plot the tree again:
data.tree <- Tool(object = phylogenetic, 
                  slot = "BuildClusterTree") 
ape::plot.phylo(x = data.tree, 
                direction = "downwards", # plot the tree without node labels
                edge.width = 1.5)

# Let's reorder some of the branches while still maintaining our hierarchy:
data.tree <- ape::rotateConstr(data.tree, constraint = c('Prolific Stem/Prog', 'Prolific TAC', 'TAC', 'Early EC Prog', 'Late EC Prog', "PC", "GC", "EEC", 'Renewing EC', 'Developing EC', 'Undeveloped EC', 'Early Immature EC', 'Late Immature EC', 'Migrating EC (Villous Tips)', 'Semi-Mature EC', 'Resting Cells'))
plot(data.tree, direction = 'downwards', edge.width = 1.5, font = 1)

#DotPlot(sobj, features = DGE_genes, assay = "RNA", group.by = 'cellID') + scale_colour_gradient2(low = "blue", mid = "grey", high = "red") + RotatedAxis()
```
# In the chuck below we make heatmaps of MT genes per cell type
```{r clusterHeatmap-MT, fig.height=4.8, fig.width=8.5, echo=FALSE}
# Heatmap on mitochondroal genes
MT_genes.ht = c("ND1", "ND2", "COX1", "COX2", "ATP8", "ATP6", "COX3", "ND3", "ND4L", "ND4", "ND5", "ND6", "CYTB") #  "CCL5", "CD52", "EPHB6", "VAV1"
# Heatmap
DoHeatmap(subset(sobj, downsample = 200), features = MT_genes.ht, assay = "RNA", label = FALSE, group.by = 'cellID') + scale_fill_gradientn(colors = c("darkturquoise", "grey90", "red")) #+ NoLegend()
# Dot plot
DotPlot(sobj, features = MT_genes.ht, assay = "RNA", scale = T, scale.by = 'size', group.by = "cellID") + 
  scale_colour_gradient2(low = "blue", mid = "white", high = "red") + 
  RotatedAxis() + coord_flip() +
  geom_point(aes(size=pct.exp), shape = 21, colour="black", stroke=0.7) + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 14, colour = "black")) + 
  theme(axis.text.y = element_text(face = 'italic'))

#DotPlot(sobj, features = MT_genes.ht, assay = "RNA") + scale_colour_gradient2(low = "black", high = "red") + RotatedAxis()
```

# In the chuck below we make dotplot of new annotated data
```{r Dotplot, fig.height=17.5, fig.width=8.5, echo=FALSE} 
# 5.5 22
DotPlot(sobj, features = DGE_genes, assay = "RNA", scale = T, scale.by = 'size', group.by = "cellID") + 
  scale_colour_gradient2(low = "blue", mid = "white", high = "red") + 
  RotatedAxis() + coord_flip() +
  geom_point(aes(size=pct.exp), shape = 21, colour="black", stroke=0.7) + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 14, colour = "black")) + 
  theme(axis.text.y = element_text(face = 'italic'))
```


#################### GO and KEGG on DGE genes ####################


# In the two chuck below we will do some basic annotation on each cluster by performing a GO and KEGG enrichments analysis.
# Here we will focus on upregulated genes first.
```{r GO enrichment on the DE genes, fig.height=10, fig.width=11, echo=FALSE}
# Connect to AnnotationHub
ann.hub <- AnnotationHub()
# Access the Ensembl database for pig
ann.hub.database <- query(ann.hub, pattern = c("Sus scrofa", "EnsDb"), ignore.case = TRUE)
# Acquire the latest annotation files
id <- ann.hub.database %>%
        mcols() %>%
        rownames() %>%
        tail(n = 1)
# Downloading the Ensembldb database
ensembl.database <- ann.hub[[id]]
# Extract gene-level information from the database
annotations <- genes(ensembl.database, 
                     return.type = "data.frame")
# Select annotations of interest
annotations <- annotations %>%
        dplyr::select(gene_id, gene_name, seq_name, gene_biotype, description)

Idents(sobj) <- "cellID" # Set the ident of the metadata to the one of interest (in this case our cellIDs)
# find markers for every cluster compared to all remaining cells, report only the positive ones
sobj.markers <- FindAllMarkers(sobj, only.pos = TRUE, min.pct = 0.15, logfc.threshold = 0.1)
sobj.markers <- subset(sobj.markers, p_val_adj < 0.05) # make sure the adjusted p-values are still < 0.05 since some genes in DE list have p_val_adj > 0.05
markers <- sobj.markers %>% group_by(cluster) %>% slice_max(n = dim(sobj)[1], order_by = avg_log2FC) # 200 for human and all for pig #dim(sobj)[1]
features <- annotations[c("gene_biotype", "description", "gene_name")] # subset only the columns of gene symbols, Ensembl IDs, and the names used for analysis 
markers <- merge(markers,
              features, 
              by.x = "gene", 
              by.y = "gene_name") # merge the DE gene lists with the additional gene information

# Put markers per cluste rin data.frame and order them
markers <- markers[order(markers$cluster, markers$p_val_adj),] # reorder by lowest to highest p-value within each cluster
#view(markers)

# Extract op genes of interest
#sobj.markers %>% group_by(cluster) %>% top_n(n = 100, wt = avg_log2FC) -> top100
#top100 <- top100[order(top100$cluster, top100$p_val_adj),] 
#top100

#Extract the markers that positive expression per cluster
GO.KEGG.sampels.pos <- markers[,1:7]   # extract the top 30 genes and clusters containing only the positive Log2FC
GO.KEGG.sampels.pos <- split(GO.KEGG.sampels.pos$gene, GO.KEGG.sampels.pos$cluster)

# order of the cells
sobj$cellID <- factor(sobj$cellID, levels = c('Prolific Stem/Prog', 'Prolific TAC', 'TAC', 'Early EC Prog', 'Late EC Prog', "PC", "GC", "EEC", 'Renewing EC', 'Developing EC', 'Undeveloped EC', 'Early Immature EC', 'Late Immature EC', 'Migrating EC (Villous Tips)', 'Semi-Mature EC', 'Resting Cells'))
levels = c('Prolific Stem/Prog', 'Prolific TAC', 'TAC', 'Early EC Prog', 'Late EC Prog', "PC", "GC", "EEC", 'Renewing EC', 'Developing EC', 'Undeveloped EC', 'Early Immature EC', 'Late Immature EC', 'Migrating EC (Villous Tips)', 'Semi-Mature EC', 'Resting Cells')

# Prepare the GO KEGG analysis for the DE up-regulated markers using the PIG database
for (i in 1: length(GO.KEGG.sampels.pos)) {
  GO.KEGG.sampels.pos[[i]] = bitr(GO.KEGG.sampels.pos[[i]], fromType="SYMBOL", toType="ENTREZID", OrgDb="org.Hs.eg.db") # convert genes to human org.Hs.eg.db 
}
# do the same here, a line like below for each cluster
genelist.all.pos <- list()
for (i in 1: length(GO.KEGG.sampels.pos)) {
  genelist.all.pos[levels[i]] <- list(GO.KEGG.sampels.pos[[i]]$ENTREZID)
}

# PIG DATABSE
# Do the GO and KEGG on biological process on DE up-regulated markers and plot top 2 per cell type
#GOclusterplot.all.pos <- compareCluster(geneCluster = genelist.all.pos, fun = "enrichGO", OrgDb = "org.Ss.eg.db", ont = 'BP', pvalueCutoff  = 0.05)
#dotplot(GOclusterplot.all.pos, showCategory=2) + ggtitle(paste("GO: Up-regulated Markers", project_name, sep = " - ")) + theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 14, colour = "black")) + 
#  theme(axis.text.y = element_text(angle = 0, hjust = 1, size = 14, colour = "black")) #+ coord_flip()

# HUMANS DATABASE GO
GOclusterplot.all.pos.hs <- compareCluster(geneCluster = genelist.all.pos, fun = "enrichGO", OrgDb = "org.Hs.eg.db", ont = 'BP', pvalueCutoff  = 0.05, )
dotplot(GOclusterplot.all.pos.hs, showCategory=2) + ggtitle(paste("GO: Up-regulated Markers", project_name, sep = " - ")) +  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 14, colour = "black")) + 
  theme(axis.text.y = element_text(angle = 0, hjust = 1, size = 14, colour = "black")) #+ coord_flip()


# No we generate a dotplot of GO pathways that we think makes sense within the statistically significant once.
# Before we only plotted the top 2, but these are not always the most relevant.
GO.table <- GOclusterplot.all.pos.hs@compareClusterResult # we save the result obtained from the GO enrichment in a new list of vectors
#GO.table # take a look for a second to see the order of the columns. 
#colnames(GO.table) # check column names that we will use to extract the data of interest
GO.table$p.adjust <- as.numeric(GO.table$p.adjust) # lets make the adjusted p-value numeric, so that we can use it in the legend of the final plot
GO.table$GeneRatio <- as.numeric(sapply(strsplit(GO.table$GeneRatio, "/"), function(x) as.numeric(x[1])/as.numeric(x[2])))  # lets make the generatio numeric, so that we can use it in the legend of the final plot. since its a string of ratio (e.g. 20/70), we have to splot by "/" and divide
# By manually analyzing the table, we will extract the index of the GO terms and put the top 3 per cluster in a table
#view(GO.table)
# Pick the GO terms of interest (FULL) in the order of the cells
GO.terms <- c(paste(GO.table$Description[1], GO.table$ID[1], sep = " - "), paste(GO.table$Description[2], GO.table$ID[2], sep = " - "), paste(GO.table$Description[4], GO.table$ID[4], sep = " - "), paste(GO.table$Description[5], GO.table$ID[5], sep = " - "), paste(GO.table$Description[19], GO.table$ID[19], sep = " - "), paste(GO.table$Description[411], GO.table$ID[411], sep = " - "), paste(GO.table$Description[412], GO.table$ID[412], sep = " - "), paste(GO.table$Description[414], GO.table$ID[414], sep = " - "), paste(GO.table$Description[416], GO.table$ID[416], sep = " - "), paste(GO.table$Description[447], GO.table$ID[447], sep = " - "), paste(GO.table$Description[879], GO.table$ID[879], sep = " - "), paste(GO.table$Description[908], GO.table$ID[908], sep = " - "), paste(GO.table$Description[909], GO.table$ID[909], sep = " - "), paste(GO.table$Description[1084], GO.table$ID[1084], sep = " - "), paste(GO.table$Description[1085], GO.table$ID[1085], sep = " - "), paste(GO.table$Description[1583], GO.table$ID[1583], sep = " - "), paste(GO.table$Description[2073], GO.table$ID[2073], sep = " - "), paste(GO.table$Description[2081], GO.table$ID[2081], sep = " - "), paste(GO.table$Description[2376], GO.table$ID[2376], sep = " - "), paste(GO.table$Description[2448], GO.table$ID[2448], sep = " - "), paste(GO.table$Description[2251], GO.table$ID[2251], sep = " - "), paste(GO.table$Description[2252], GO.table$ID[2252], sep = " - "), paste(GO.table$Description[2253], GO.table$ID[2253], sep = " - "), paste(GO.table$Description[2254], GO.table$ID[2254], sep = " - "), paste(GO.table$Description[2557], GO.table$ID[2557], sep = " - "), paste(GO.table$Description[2558], GO.table$ID[2558], sep = " - "), paste(GO.table$Description[2592], GO.table$ID[2592], sep = " - "), paste(GO.table$Description[2600], GO.table$ID[2600], sep = " - "), paste(GO.table$Description[2687], GO.table$ID[2687], sep = " - "), paste(GO.table$Description[2688], GO.table$ID[2688], sep = " - "), paste(GO.table$Description[2697], GO.table$ID[2697], sep = " - "), paste(GO.table$Description[2709], GO.table$ID[2709], sep = " - "), paste(GO.table$Description[2731], GO.table$ID[2731], sep = " - "), paste(GO.table$Description[2751], GO.table$ID[2751], sep = " - "),  paste(GO.table$Description[2765], GO.table$ID[2765], sep = " - "), paste(GO.table$Description[2776], GO.table$ID[2776], sep = " - "), paste(GO.table$Description[2783], GO.table$ID[2783], sep = " - "), paste(GO.table$Description[3058], GO.table$ID[3058], sep = " - "), paste(GO.table$Description[3245], GO.table$ID[3245], sep = " - "), paste(GO.table$Description[3712], GO.table$ID[3712], sep = " - "), paste(GO.table$Description[3715], GO.table$ID[3715], sep = " - "), paste(GO.table$Description[3719], GO.table$ID[3719], sep = " - "), paste(GO.table$Description[3741], GO.table$ID[3741], sep = " - "), paste(GO.table$Description[3758], GO.table$ID[3758], sep = " - "), paste(GO.table$Description[3760], GO.table$ID[3760], sep = " - "), paste(GO.table$Description[3823], GO.table$ID[3823], sep = " - "), paste(GO.table$Description[4699], GO.table$ID[4699], sep = " - "), paste(GO.table$Description[4700], GO.table$ID[4700], sep = " - "), paste(GO.table$Description[4701], GO.table$ID[4701], sep = " - "), paste(GO.table$Description[5469], GO.table$ID[5469], sep = " - "), paste(GO.table$Description[5471], GO.table$ID[5471], sep = " - "), paste(GO.table$Description[5473], GO.table$ID[5473], sep = " - "), paste(GO.table$Description[5474], GO.table$ID[5474], sep = " - "), paste(GO.table$Description[5479], GO.table$ID[5479], sep = " - "), paste(GO.table$Description[5488], GO.table$ID[5488], sep = " - "), paste(GO.table$Description[5546], GO.table$ID[5546], sep = " - "))

# Pic the GO terms of interest (index) (for filtering the full table)
GO.terms.index <- c(paste(GO.table$Description[1]), paste(GO.table$Description[2]), paste(GO.table$Description[4]), paste(GO.table$Description[5]), paste(GO.table$Description[19]), paste(GO.table$Description[411]), paste(GO.table$Description[412]), paste(GO.table$Description[414]), paste(GO.table$Description[416]), paste(GO.table$Description[447]), paste(GO.table$Description[879]), paste(GO.table$Description[908]), paste(GO.table$Description[909]), paste(GO.table$Description[1084]), paste(GO.table$Description[1085]), paste(GO.table$Description[1583]), paste(GO.table$Description[2073]), paste(GO.table$Description[2081]), paste(GO.table$Description[2376]), paste(GO.table$Description[2448]), paste(GO.table$Description[2251]), paste(GO.table$Description[2552]), paste(GO.table$Description[2553]), paste(GO.table$Description[2554]), paste(GO.table$Description[2558]), paste(GO.table$Description[2592]), paste(GO.table$Description[2600]), paste(GO.table$Description[2687]), paste(GO.table$Description[2688]), paste(GO.table$Description[2697]), paste(GO.table$Description[2709]), paste(GO.table$Description[2731]), paste(GO.table$Description[2751]), paste(GO.table$Description[2765]), paste(GO.table$Description[2776]), paste(GO.table$Description[2783]), paste(GO.table$Description[3058]), paste(GO.table$Description[3245]), paste(GO.table$Description[3712]), paste(GO.table$Description[3715]), paste(GO.table$Description[3719]), paste(GO.table$Description[3741]), paste(GO.table$Description[3758]), paste(GO.table$Description[3760]), paste(GO.table$Description[3823]),paste(GO.table$Description[4699]), paste(GO.table$Description[4700]), paste(GO.table$Description[4701]), paste(GO.table$Description[5469]), paste(GO.table$Description[5471]), paste(GO.table$Description[5473]), paste(GO.table$Description[5474]), paste(GO.table$Description[5479]), paste(GO.table$Description[5488]), paste(GO.table$Description[5546]))

# Make data frame of the GO.terms.index so that we can remove rows based on index
GO.terms.index <- as.data.frame(GO.terms.index)
# Remove these rows, as they are duplicates
GO.terms.index <- GO.terms.index[-c(11, 16, 18, 21, 28, 54),]
# Now only keep the GO terms of interest from the full data
GO.table <- GO.table[GO.table$Description %in% GO.terms.index, ]
# Order of the cells types
sobj$cellID <- factor(sobj$cellID, levels = c('Prolific Stem/Prog', 'Prolific TAC', 'TAC', 'Early EC Prog', 'Late EC Prog', "PC", "GC", "EEC", 'Renewing EC', 'Developing EC', 'Undeveloped EC', 'Early Immature EC', 'Late Immature EC', 'Migrating EC (Villous Tips)', 'Semi-Mature EC', 'Resting Cells'))
# Now combine the GO term ID and Description in new column to use for plotting
GO.table$term <- paste(GO.table$Description, " - ", GO.table$ID)
# TEST CODE #
# Order the terms accordingly and remove duplicated terms
#GO.terms.sorted <- unique(GO.terms) # user previous vector that we don't use any more
# Sort according to the term columns
#GO.table$term <- factor(GO.table$term, levels = c(GO.table$term))

# Dotplot the GO terms of interest
ggplot(GO.table) +
  geom_point(aes(x = reorder(term, GeneRatio, decreasing = TRUE), 
                 y = Cluster,
                 size = GeneRatio,
                 fill = p.adjust), colour="black", shape=21, stroke = 0.5) +  #colour="black", shape=21, stroke = 0.5
  theme_bw() +
  scale_color_gradient(low = 'red', high = 'blue') +
  coord_flip() + coord_flip() +  
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 12, colour = "black")) + 
  theme(axis.text.y = element_text(angle = 0, hjust = 1, size = 12, colour = "black")) 
```

```{r KEGG enrichment on the DE genes, fig.height=12, fig.width=15, echo=FALSE, echo=FALSE}
# PIG DATABSE
# KEGG
# suported orgnaism can ben found here: https://www.genome.jp/kegg/catalog/org_list.html
#KEGGclusterplot.all.pos <- compareCluster(geneCluster = genelist.all.pos, fun = "enrichKEGG", organism = "ssc", pvalueCutoff  = 0.05)
#dotplot(KEGGclusterplot.all.pos, showCategory=1) + ggtitle(paste("KEGG: Up-regulated Markers", project_name, sep = " - ")) + theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 14, colour = "black"))  #+ coord_flip()

# HUMANS DATABASE
# KEGG
KEGGclusterplot.all.pos.hs <- compareCluster(geneCluster = genelist.all.pos, fun = "enrichKEGG", organism = "hsa", pvalueCutoff  = 0.05,)
dotplot(KEGGclusterplot.all.pos.hs,  showCategory=2) + ggtitle("KEGG - Hs: Up-regulated Markers - Pig Ileum Organoid") 
```


#################### Saving Seurat OBJ ####################


# In the chuck below, we ave our Seurat object
```{r saving Seurat object, echo=FALSE}
# Add new metadata containing cell origin (this will be used for itegration and comparison to tissue)
n.cells <- length(sobj@meta.data$seurat_clusters)
orig.cells <- rep("Ileum Org", n.cells)
sobj <- AddMetaData(object = sobj, metadata = orig.cells, col.name = 'cell.origin')

# Save the Seurat object
SaveH5Seurat(sobj, overwrite = TRUE, filename = "ileum_pig_org.NEW.without.secretoryProg")

# Make backup and keep this!
sobj1 <- sobj
```