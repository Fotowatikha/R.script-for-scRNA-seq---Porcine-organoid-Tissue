---
title: "Co-expression analysis"
output: html_notebook
---

# In the chuck below, we load in all the essential libraries for the data analysis. 
```{r Load Libraries, echo=FALSE, results=FALSE, include=FALSE}
library(dplyr)
library(dbplyr)
library(Seurat)
library(SeuratDisk)
library(SeuratData)
library(patchwork) # Also being used for Cellchat (but main purpose was something else)
library(hdf5r)
library(tidyverse)
library(gsubfn)
library(ggplot2)
library(RColorBrewer)
library(writexl)

# For annotation, gene name conversions
library(rPanglaoDB)
library(AnnotationHub)
library(ensembldb)
library(clusterProfiler)
library(org.Hs.eg.db)
library(org.Ss.eg.db)
library(DropletUtils)
library(biomaRt)

# to download external library
library(devtools)

# for Monocle3
library(SeuratWrappers)
library(monocle3)

# plotting and data science packages
library(tidyverse)
library(cowplot)
library(patchwork) # also used for cellchat 

# co-expression network analysis packages:
# NOTE: DOWNLAOD THE "FORTRAN compiler" on Mac systems using ARM64. This compiler is not integrated in Xcode.
library(qlcMatrix)  
library(impute) 
library(preprocessCore) 
library(WGCNA)
library(hdWGCNA)

# deconvolution
library(Biobase) # install this package if needed (for simulated data)
library(BisqueRNA)

# Cellchat and dependencies:
library(NMF)
library(circlize)
library(ComplexHeatmap)
library(presto)
library(CellChat)
```

# In the chuck below we take our stored and annotated scRNAseq data + Pseudotime in the metadata (from the Seurat object) and disect the pseudtimes into multiple peices from the starting point. The idea here is that the starting point of the trjectory (Stem/Prog cells) go toward multiple directions (i.g. secretory, absoorbtive lineage), and thus these directions have to be made in order to accurately study the WGCNA of the secretory and absorbtive separately. This way we can also compare it to the Organoid more easly.
# Make sure to switch to Seaurat4 to make this work!
```{r WGCNA setup,  fig.height=4, fig.width=8, echo=FALSE}
# Collect the annotated cell types, which is stored as active.idents in our object
# Open the Seurat object containing the annotated Ileum Tissue with pseudotime information in the metadata
sobj.tiss <- LoadH5Seurat("/Users/hamid/Desktop/ABG MSc project/Raw data/Ileum tissue/Wiarda - Ileum Tissue (non-immune)/WGCNA/ileum_pig_tiss(WIERDA).epithel.v4.WGCNA.h5seurat")
# Load in the Organoid Seurat object
sobj.org <- LoadH5Seurat("/Users/hamid/Desktop/ABG MSc project/Raw data/Ileum tissue/Wiarda - Ileum Tissue (non-immune)/WGCNA/ileum_pig_org.v4.WGCNA.h5seurat")
# level the cell types
Idents(sobj.org) <- "cellID"
sobj.org$cellID <- factor(sobj.org$cellID, levels = c('Prolific Stem/Prog', 'Prolific TAC', 'TAC', 'Early EC Prog', 'Late EC Prog', 'Renewing EC', 'Developing EC', 'Undeveloped EC', 'Early Immature EC', 'Late Immature EC', 'Migrating EC (Villous Tips)', 'Semi-Mature EC', 'Resting Cells', "PC", "GC", "EEC"))

# Set the the cellID as active indents and put groups to be studied (as a function of pseuodtime) in a vector
Idents(sobj) <- "cellID"
sobj@active.ident
groups <- c('Prolific Stem/Prog *', 'EC Prog *', 'Developing EC *', 'Early EC *', 'Late EC *', 'PC *', 'GC *', 'EEC *', 'TC *')

# IMPORTANT!!!!!!!!!!!!!!!!!!!!!!!
# WGCNA package is NOT compatible with Seurat_v5, so please convert it to a V4/v5 and save yourself some sleepless nights (screw you v5 developer!!!)
# Use the line below (not that we do not remove the layer, but instead use the layers to make a new RNA assay outside the layers where the raw count matrix will be stored)
# Only run this code if working with Seurat V5 object. In our case we do it in V4
#sobj[["RNA"]] <- as(object = sobj[["RNA"]], Class = "Assay")
#JoinLayers(sobj1)

# Separate pseudotime trajectories by the different mature cells
# For Stem to Enterocytes
sobj$EC_pseudotime <- ifelse(sobj$cellID %in% c('Prolific Stem/Prog *', 'EC Prog *', 'Developing EC *', 'Early EC *', 'Late EC *'), sobj$pseudotime, NA)
# From stem to secretory cells
sobj$SEC_pseudotime <- ifelse(sobj$cellID %in% c('Prolific Stem/Prog *', 'EC Prog *', 'PC *', 'GC *', 'EEC *', 'TC *'), sobj$pseudotime, NA)

# Make the plotting:
# Find the coordinates of the UMAP from the clustering
sobj$UMAP1 <- sobj@reductions$umap@cell.embeddings[,1]
sobj$UMAP2 <- sobj@reductions$umap@cell.embeddings[,2]

# PLot EC
p1 <- sobj@meta.data %>%
  ggplot(aes(x=UMAP1, y=UMAP2, color=EC_pseudotime)) +
  ggrastr::rasterise(geom_point(size=1), dpi=500, scale=0.75) +
  coord_equal() +
  scale_color_gradientn(colors=plasma(256), na.value='grey') +
  umap_theme()
# Plot SEC
p2 <- sobj@meta.data %>%
  ggplot(aes(x=UMAP1, y=UMAP2, color=SEC_pseudotime)) +
  ggrastr::rasterise(geom_point(size=1), dpi=500, scale=0.75) +
  coord_equal() +
  scale_color_gradientn(colors=viridis(256), na.value='grey') +
  umap_theme()
# Print plots
print(p1)
print(p2)

#### Do Weighted Gene Correlations Network Analysis (WGCNA) ####

# Setup WGCNA experiment in the Seurat object
# Notice that we are actually adding a new slot in our object, named "misc"
# Here we only choose to work with genes that are expressed at least in 5% of our total data set.
sobj <- SetupForWGCNA(
  sobj,
  gene_select = "fraction",
  fraction = 0.05, # must be in 5% of cells
  wgcna_name = 'trajectory_WGCAN.Ileum.Tiss'
)

sobj@meta.data
# Now we will make the metacells, which are aggregates of small groups of similar cells from the same biological sample of origin using our previously annotated clusters.
# Here, we only want to construct metacells from the cells types that we previously annotated and thus we pass that information to hdWGCNA via the group.by option. 
# We also construct metacells for each cell type separately. To archive this, we are grouping by cellID
sobj <- MetacellsByGroups(
  seurat_obj = sobj,
  group.by = "cellID",
  k = 18, # K18 is the maximum we can use for this dataset, as the smalles number is cells are the EECs
  target_metacells=dim(sobj)[2], # dim(sobj)[2] is the maximum number of cells in our data
  ident.group = 'cellID',
  min_cells=0, # set to 0 because we want to include all cells
  max_shared=10, assay = 'RNA', 
  slot = "counts", )

# Now we will CPM(10.000 factor) normalize our new object containing the WGCNA metacells
sobj <- NormalizeMetacells(sobj)

# Here we are going to choose the expression matrix that we will use for the WGCNA network analysis
# In order to continue with the normalized count matrix, we will specify that using the data slot
sobj <- SetDatExpr(
  sobj,
  group.by='cellID',
  group_name = groups, 
  assay = "RNA", 
  slot = "data", # we use the normalized count matrix
  use_metacells = TRUE, 
)

# hdWGCNA constructs a gene-gene correlation adjacency matrix to infer co-expression relationships between genes. The correlations are raised to a power to reduce the amount of noise present in the correlation matrix, thereby retaining the strong connections and removing the weak connections. Therefore, it is critical to determine a proper value for the soft power threshold.
# test soft power parameter
sobj <- TestSoftPowers(sobj, networkType = "signed")

# Plot the power treshold:
PlotSoftPowers(sobj)

# Now we construct the correlation co-expression network using the optimal soft power treshold of 5 that we previously found
sobj <- ConstructNetwork(
    sobj, soft_power = 5, # We found that soft power 4 was most optimal
    tom_name='trajectory_WGCAN.Ileum.Tiss', 
    overwrite_tom=TRUE, 
)

# Now we will compute the Module Eigengenes of each calculated co-expression module
# Module Eigengenes are computed by PCA on the subset of genes within each co-expression module. Here, we consider the PC1 of each of these PCA runs as the Module Eigengenes
# Compute module eigengenes & connectivity
sobj <- ModuleEigengenes(sobj) 

# Now we will look at those genes which are highly connected within each module. Therefore we wish to determine the Eigengene-based connectivity (too much jargon, just connectivity based on correlation), of each gene. We are essentially computing pairwise correlations between genes and previously calculated Module Eigengenes. 
sobj <- ModuleConnectivity(sobj) # # group.by.vars = "cellID" if we want to compare between clusters instead of pseudotime

# rename the modules from color naminf to Ileum.tiss M (M for module)
sobj <- ResetModuleNames(
  sobj,
  new_name = "Ileum-M"
)
```

# In the chunk below we will plot a dendrogram demonstrating the relevant modeules found
```{r WGCNA dendrogram of modules,  fig.height=3, fig.width=6, echo=FALSE}
# plot dendro of modules (note that the grey colors are useless)
dontro <- PlotDendrogram(sobj, main='hdWGCNA Dendrogram: Ileum Tissue', groupLabels = "Identified Modules")

# Get TOM
#TOM <- GetTOM(sobj)

```

# In the chun below make a dotplot of the eigengenes per module in each cell population
# Additionally, we can also reset the metadaa with the eigen genes removed (this should only be done if required for further downstream analysis)
# We will also project the modules found in tissue to the organoid and see the difference
```{r WGCNA dotplot of modules,  fig.height=5.4, fig.width=6.6, echo=FALSE}
# Dotplot the modules per cell type
MEs <- GetMEs(sobj) # Get the Module Eigengenes from the Seurat object
MEs
modules <- GetModules(sobj) # Get the highly connected genes within each module (hub genes)
modules
mods <- levels(modules$module)
mods
mods <- mods[mods!='grey'] # We omit the grey ones, because they don't have co-expressed genes
mods
# Put the Module Eigengens in the Seurat metadata slot
meta <- sobj@meta.data
sobj@meta.data <- cbind(meta, MEs)
sobj@meta.data
sobj$grey <- NULL # remove the grey module
# level the cellIDs by personal preference
sobj$cellID <- factor(sobj$cellID, levels = c('Prolific Stem/Prog *', 'EC Prog *', 'PC *', 'Developing EC *', 'TC *', 'Early EC *', 'GC *', 'EEC *', 'Late EC *'))
# Make dotplot
DotPlot(sobj, features = mods, group.by = "cellID") + scale_colour_gradient2(low = "red", mid = "white", high = "purple") + 
  RotatedAxis() + 
  geom_point(aes(size=pct.exp), shape = 21, colour="black", stroke=0.7) 
# restore the metadata slot is needed
#sobj@meta.data <- meta



### Project the Eigengene modules on Ileum Organoid ###

# Now we will project the modules from the ileum tissue dataset into the Organoid dataset
# This will be carried out by "ProjectModules" function to compute the module eigengenes in the organoid dataset based on the gene modules in the tissue
# We will not run "ModuleExprScore" funtion to compute hub gene expression scores for the organoid modules, because we only want to check how it compares to tissue, as we wont do any downstream analysis in the organoid. The same is true for skipping "ModuleConnectivity" function to compute connectivity (kME) in organoid

# project the tissue WGCNA module data to organoid
sobj_query <- ProjectModules(
  seurat_obj = sobj.org,
  seurat_ref = sobj,
  wgcna_name_proj="trajectory_WGCAN.Ileum.Org.Projected", 
  wgcna_name = "trajectory_WGCAN.Ileum.Tiss", 
  overlap_proportion = 0.90, # proportion of genes that must be in the organoid to be projected
)

# Module Eigengenes are computed by PCA on the subset of genes within each co-expression module.
sobj_query <- ModuleEigengenes(sobj_query) 

# Hub genes. 
sobj_query <- ModuleConnectivity(sobj_query) # 

# Dotplot the modules per cell type in organoid
organoid_hMEs <- GetMEs(sobj_query) # the the highly connected genes in organoid
# Append the highly connected genes in the organoid metadata
sobj_query@meta.data <- cbind(sobj_query@meta.data, organoid_hMEs)
# Remove the grey slot
sobj_query$grey <- NULL
# level the cellIDs by personal preference
sobj_query$cellID <- factor(sobj_query$cellID, levels = c('Prolific Stem/Prog', 'Prolific TAC', 'Early EC Prog', 'Late EC Prog', 'TAC', 'Developing EC', 'Renewing EC', "EEC", "PC", "GC", 'Resting Cells', 'Early Immature EC', 'Semi-Mature EC', 'Migrating EC (Villous Tips)', 'Late Immature EC', 'Undeveloped EC'))
# Make dotplot for organoid
DotPlot(sobj_query, features = mods, group.by = "cellID") + scale_colour_gradient2(low = "red", mid = "white", high = "purple") + 
  RotatedAxis() + 
  geom_point(aes(size=pct.exp), shape = 21, colour="black", stroke=0.7) 
```

# In the chunk below we plot the eigengenes per module as a funtion of pseudotime for both Stem-to-EC and Stem-to-SEC trajectories for both tissue and projected organoid
```{r WGCNA plot eigengenes per module as function of pseudotime,  fig.height=2, fig.width=3, echo=FALSE}
#### Plot the modules as function of pseudotime ####
for (i in 1:length(x = sobj@meta.data[14:length(sobj@meta.data)])) {
  mod_plot <- ggplot(sobj@meta.data, aes(y=sobj[[colnames(sobj@meta.data[13+i])]][, 1])) + 
    geom_smooth(aes(x=sobj$EC_pseudotime), size=2, color="green") +
    geom_smooth(aes(x=sobj$SEC_pseudotime), size=2, color="orange") +
    ggtitle(paste(print(colnames(sobj@meta.data[13+i])))) +
    ylab("Module Eigengene") + 
    xlab("Pseudotime") + 
    theme_bw() + # make filler white
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) # remove raster
  print(mod_plot)
}



### Now do the same in organoid ###


# Separate pseudotime trajectories
# For Stem to Enterocytes
sobj_query$cellID <- factor(sobj_query$cellID, levels = c('Prolific Stem/Prog', 'Prolific TAC', 'TAC', 'Early EC Prog', 'Late EC Prog', 'Renewing EC', 'Developing EC', 'Undeveloped EC', 'Early Immature EC', 'Late Immature EC', 'Migrating EC (Villous Tips)', 'Semi-Mature EC', 'Resting Cells', "PC", "GC", "EEC"))

sobj_query$EC_pseudotime <- ifelse(sobj_query$cellID %in% c('Prolific Stem/Prog', 'Prolific TAC', 'TAC', 'Early EC Prog', 'Late EC Prog', 'Developing EC', 'Early Immature EC', 'Late Immature EC', 'Migrating EC (Villous Tips)', 'Semi-Mature EC'), sobj_query$pseudotime, NA)
# From stem to secretory cells
sobj_query$SEC_pseudotime <- ifelse(sobj_query$cellID %in% c('Prolific Stem/Prog', 'Prolific TAC', 'TAC', 'Early EC Prog', 'Late EC Prog', 'Renewing EC', 'Developing EC', "PC", "GC", "EEC"), sobj_query$pseudotime, NA)

# Now plot the module eigengenes as a fucntion of pseudotime in Organoid
for (i in 1:length(x = sobj_query@meta.data[9:17])) {
  mod_plot <- ggplot(sobj_query@meta.data, aes(y=sobj_query[[colnames(sobj_query@meta.data[8+i])]][, 1])) + 
    geom_smooth(aes(x=sobj_query$EC_pseudotime), size=2, color="green") +
    geom_smooth(aes(x=sobj_query$SEC_pseudotime), size=2, color="orange") +
    ggtitle(paste(print(colnames(sobj_query@meta.data[8+i])))) +
    ylab("Module Eigengene") + 
    xlab("Pseudotime") + 
    theme_bw() + # make filler white
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) # remove raster
  print(mod_plot)
}




### Combined plot to see difference between organoid and tissue in one trjectory

# Make new dataframe for organoid and bring over the information form the original metadata
sobj_query$cell.origin <- NULL
sobj_query$cell.origin <- "Ileum Org"
org.df <- data.frame(sobj_query$`Ileum-M1`, sobj_query$`Ileum-M2`, sobj_query$`Ileum-M3`, sobj_query$`Ileum-M4`, sobj_query$`Ileum-M5`, sobj_query$`Ileum-M6`, sobj_query$`Ileum-M7`, sobj_query$`Ileum-M8`, sobj_query$`Ileum-M9`, sobj_query$EC_pseudotime, sobj_query$SEC_pseudotime, sobj_query$cell.origin)
colnames(org.df) <- c('M1','M2','M3', 'M4', 'M5', 'M6', 'M7', 'M8', 'M9', 'EC_pseudotime', 'SEC_pseudotime', 'cell.origin') # adjust col names so that we can rbind with tisse data
# Make new dataframe for tissue and bring over the information form the original metadata
tiss.df <- data.frame(sobj$`Ileum-M1`, sobj$`Ileum-M2`, sobj$`Ileum-M3`, sobj$`Ileum-M4`, sobj$`Ileum-M5`, sobj$`Ileum-M6`, sobj$`Ileum-M7`, sobj$`Ileum-M8`, sobj$`Ileum-M9`, sobj$EC_pseudotime, sobj$SEC_pseudotime, sobj$cell.origin)
colnames(tiss.df) <- c('M1','M2','M3', 'M4', 'M5', 'M6', 'M7', 'M8', 'M9', 'EC_pseudotime', 'SEC_pseudotime', 'cell.origin') 
# Combine the dataframes
org.tiss.comb <- rbind(org.df, tiss.df)

# Now plot the trajectory from stem to ECs
for (i in 1:length(x = org.tiss.comb[1:9])) {
  print(i)
  mod_plot <- ggplot(org.tiss.comb, aes(x=EC_pseudotime, y=org.tiss.comb[colnames(org.tiss.comb[i])][, 1], colour = cell.origin)) + 
    geom_smooth() + 
    ggtitle(paste(print(colnames(org.tiss.comb[i])))) +
    ylab("Module Eigengene") + 
    xlab("Pseudotime") + 
    theme_bw() + # make filler white
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) + # remove raster
    NoLegend()
  print(mod_plot)
}
# Now plot the trajectory from stem to Secretory
for (i in 1:length(x = org.tiss.comb[1:9])) {
  print(i)
  mod_plot <- ggplot(org.tiss.comb, aes(x=SEC_pseudotime, y=org.tiss.comb[colnames(org.tiss.comb[i])][, 1], colour = cell.origin)) + 
    geom_smooth() + 
    ggtitle(paste(print(colnames(org.tiss.comb[i])))) +
    ylab("Module Eigengene") + 
    xlab("Pseudotime") + 
    theme_bw() +
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank()) +
    NoLegend()
  print(mod_plot)
}

```

# In the chunck below we plot the eigengenes per module in the UMAP space containing the epithelial cells and projected organoid
```{r WGCNA Featureplot of eigengenes per module in UMAP space, fig.height=7, fig.width=7, echo=FALSE}
# Make a featureplot of module eigengenes for each module
MEs <- GetMEs(sobj, harmonized = FALSE)
plot_list <- ModuleFeaturePlot(
  sobj,
  features='MEs', # plot the hMEs
  order=TRUE, plot_ratio = 1.5  # order so the points with highest MEs are on top
)
wrap_plots(plot_list, ncol = 3)



### Do the same for organoid  ###
plot_list <- ModuleFeaturePlot(
  sobj_query,
  features='MEs', # plot the hMEs
  order=TRUE, plot_ratio = 1.5  # order so the points with highest MEs are on top
)
wrap_plots(plot_list, ncol = 3)
```

```{r WGCNA plot top Hub genes on organoid, fig.height=5, fig.width=8.5, echo=FALSE}
module_by.kME <- GetHubGenes(sobj, n_hubs = dim(sobj)[1], wgcna_name = "trajectory_WGCAN.Ileum.Tiss",) # get all the hub genes per module
# Sort based on kME
module_by.kME <- module_by.kME[order(module_by.kME$module, module_by.kME$kME, decreasing = TRUE),]
# Pick the top 10 per module
module_by.kME <- module_by.kME %>% group_by(module) %>% slice_max(n = 20, order_by = kME)

# convert the ENS ids to human homologs/ortologs
human.genes = useMart("ensembl", dataset = "hsapiens_gene_ensembl", host = "https://dec2021.archive.ensembl.org/") # Dec 2021 is latest
pig.genes = useMart("ensembl", dataset = "sscrofa_gene_ensembl", host = "https://dec2021.archive.ensembl.org/")
# Find pig Homologous genes
annot_table <- getLDS(mart = human.genes, attributes = c('ensembl_gene_id','hgnc_symbol','external_gene_name','chromosome_name'), martL = pig.genes, attributesL = c('ensembl_gene_id','external_gene_name','chromosome_name','gene_biotype'))
# Get the Ensembl ID to be converted to human
ENS <- module_by.kME$gene_name[c(grep("ENS", module_by.kME$gene_name))]
# find the orthologs in human
orthologs <- getLDS(attributes = c("ensembl_gene_id", "external_gene_name"), filters = "ensembl_gene_id", 
    values = ENS, mart = pig.genes, attributesL = c("hgnc_symbol", "ensembl_gene_id"), martL = human.genes)
# Find the positions of our ENSEMBL ids in the orthologs output
ENSEMBL_IDs.pos <- na.omit(c(match(c(paste(ENS)), orthologs$Gene.stable.ID))) # and remove NAs (ENS with no gene IDs)
# Now find the GeneIDs in orthologs using the ENSEMBL_IDs.pos
geneIDs <- orthologs$HGNC.symbol[ENSEMBL_IDs.pos] 
# Since not all ENSEMBL_IDs have true gene name, we need to find the index of geneIDs with no gene name and remove their corresponding ENSEMBL_IDs
# To do this, we will remove genes with no names, and then find the index of these genesID in orthologs in order to find the corresponding ENSEMBL ids
geneIDs <- as.character(geneIDs[geneIDs !=""])

geneIDs.pos <- c(match(c(paste(geneIDs)), orthologs$HGNC.symbol)) # find position of gene IDs in them
ENSEMBL_IDs <- orthologs$Gene.stable.ID[geneIDs.pos] # find the ENSEMBL_IDs using the positions of the gene IDs
# Now we have found all the ENSEMBL ids that have a annotated gene name (winch are also found in our Seurat object)
# We will their final positions in our Seurat object and finally replace them with the true gene ID
# NOTE: The order of the genes are conserved using the method above
final.pos <- c(match(c(paste(ENSEMBL_IDs)),module_by.kME$gene_name))
# replace the name of that genes for all slots
module_by.kME$gene_name[c(final.pos)] <- c(paste(geneIDs))

X <- 1
Y <- 20
for (i in 1:length(x = unique(module_by.kME$module))) {
  plot_hub_org <- DotPlot(sobj_query, features = module_by.kME$gene_name[X:Y], assay = "RNA", scale = T, scale.by = 'size', group.by = "cellID") + 
  scale_colour_gradient2(low = "blue", mid = "white", high = "red") + 
  RotatedAxis() + coord_flip() +
  geom_point(aes(size=pct.exp), shape = 21, colour="black", stroke=0.7) + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 14, colour = "black")) + 
  theme(axis.text.y = element_text(face = 'italic'))
  
  plot_hub_tiss <- DotPlot(sobj, features = module_by.kME$gene_name[X:Y], assay = "RNA", scale = T, scale.by = 'size', group.by = "cellID") + 
  scale_colour_gradient2(low = "blue", mid = "white", high = "red") + 
  RotatedAxis() + coord_flip() +
  geom_point(aes(size=pct.exp), shape = 21, colour="black", stroke=0.7) + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 14, colour = "black")) + 
  theme(axis.text.y = element_text(face = 'italic'))
  
  X <- Y 
  Y <- Y + 20
  
  print(plot_hub_org)
  print(plot_hub_tiss)
  
}

```


# In the chuck below we will look a closer look at the correlation between the modules
```{r WGCNA module correlation, fig.height=5, fig.width=5, echo=FALSE}
# plot module correlagram
ModuleCorrelogram(sobj, order="alphabet") # ordering "alphabet"  to ensure we go from 1 to 9
```

# From each module of interest, here we collect the eigengenes which are highly connected within each module
# From the top highly connected eigengenes we find the transcription factors (that presumably are involved in development)
```{r Collect the eigen genes per module with sorted on connectivity score, echo=FALSE}
#### Now get the top genes per module and extract the transcription factors ####

# collect the top Eigengenes per module based on connectivity
module_by.kME <- GetHubGenes(sobj, n_hubs = dim(sobj)[1], wgcna_name = "trajectory_WGCAN.Ileum.Tiss", ) # Ileum-M1, Ileum-M2, Ileum-M3, Ileum-M4, Ileum-M5, Ileum-M6, Ileum-M7, Ileum-M8, Ileum-M9
# Import the list of transcription factors from pig database
Ss_TF <- read.delim("/Users/hamid/Desktop/ABG MSc project/Raw data/Ileum tissue/Wiarda - Ileum Tissue (non-immune)/WGCNA/Sus_scrofa_TF.txt")
# Make a table of all found TFs found as hubs and put in table (table contains TF, HUB and KME)
TFtable <- module_by.kME[module_by.kME$gene_name %in% Ss_TF$Symbol, ]
TFtable <- TFtable[order(TFtable$module, TFtable$kME),] # sort on kME per module
save(TFtable, file="/Users/hamid/Desktop/ABG MSc project/Raw data/Ileum tissue/Wiarda - Ileum Tissue (non-immune)/WGCNA/Hub TFs/Hub_TFs.kME") 
# No only keep TFs with kME above 0.5. THese TFs are well connected and are impactfull in their modules
TFtable <- subset(TFtable, kME >= 0.49)
save(TFtable, file="/Users/hamid/Desktop/ABG MSc project/Raw data/Ileum tissue/Wiarda - Ileum Tissue (non-immune)/WGCNA/Hub TFs/Top_Hub_TFs.kME>0.5") 

TFtable
TF.per.module
# Put the TFs in vector of lists per module
sobj$grey <- NULL # remove the grey module
# Put the TFs in a list per module (the TFs at the end have the highest connectivity per module)
TF.per.module <- c() # make empty list to store the TFs per module
for (i in 1:length(x = sobj@meta.data[14:length(sobj@meta.data)])) { # loop through the metadata columns containing the module names
  module_by.kME <- GetHubGenes(sobj, n_hubs = dim(module_by.kME)[1], wgcna_name = "trajectory_WGCAN.Ileum.Tiss", mods = colnames(sobj@meta.data[13+i])) # find eigen genes per module
  TF <- match(module_by.kME$gene_name, Ss_TF$Symbol) # find the position (index) of TFs per module
  TF <- na.omit(TF) # omit NA positions
  TF.per.module[[colnames(sobj@meta.data[13+i])]] <- Ss_TF[TF, ] # Append the found TFs in the empty list
}
# Save the list of the transcription factors
save(TF.per.module, file="/Users/hamid/Desktop/ABG MSc project/Raw data/Ileum tissue/Wiarda - Ileum Tissue (non-immune)/WGCNA/Hub TFs/Hub_Transcription_Factors") 
```

# Here we make a dotplot of the transcription facotrs that we previously found in the the weighted co-expression matrix as a function of pseudotime
```{r Dotplot, fig.height=5.5, fig.width=21, echo=FALSE}
# Set the ident of the metadata to the one of interest (in this case our cellIDs)
Idents(sobj.org) <- "cellID" 
Idents(sobj) <- "cellID" 

# Make a vector of all transcription factors found markers
load(file="/Users/hamid/Desktop/ABG MSc project/Raw data/Ileum tissue/Wiarda - Ileum Tissue (non-immune)/WGCNA/Hub TFs/Hub_Transcription_Factors")
TF.per.module

# Put the TFs in order of module in a vector
TF.genes <- c(TF.per.module$`Ileum-M1`$Symbol, TF.per.module$`Ileum-M2`$Symbol, TF.per.module$`Ileum-M3`$Symbol, TF.per.module$`Ileum-M4`$Symbol, TF.per.module$`Ileum-M5`$Symbol, TF.per.module$`Ileum-M6`$Symbol, TF.per.module$`Ileum-M7`$Symbol, TF.per.module$`Ileum-M8`$Symbol, TF.per.module$`Ileum-M9`$Symbol)

# level the cellIDs by personal preference
# Org
sobj.org$cellID <- factor(sobj.org$cellID, levels = c('Prolific Stem/Prog', 'Prolific TAC', 'Early EC Prog', 'Late EC Prog', 'TAC', 'Developing EC', 'Renewing EC', "EEC", "PC", "GC", 'Resting Cells', 'Early Immature EC', 'Semi-Mature EC', 'Migrating EC (Villous Tips)', 'Late Immature EC', 'Undeveloped EC'))
# Tiss
sobj$cellID <- factor(sobj$cellID, levels = c('Prolific Stem/Prog *', 'EC Prog *', 'PC *', 'Developing EC *', 'TC *', 'Early EC *', 'GC *', 'EEC *', 'Late EC *'))


# Make dotplot
# Org # TF.genes
DotPlot(sobj.org, features = TF.genes, assay = "RNA", scale = T, scale.by = 'size', group.by = "cellID") + 
  scale_colour_gradient2(low = "blue", mid = "white", high = "red") + 
  RotatedAxis() + 
  geom_point(aes(size=pct.exp), shape = 21, colour="black", stroke=0.7)
# Tiss
DotPlot(sobj, features =TF.genes, assay = "RNA", scale = T, scale.by = 'size', group.by = "cellID") + 
  scale_colour_gradient2(low = "blue", mid = "white", high = "red") + 
  RotatedAxis() + 
  geom_point(aes(size=pct.exp), shape = 21, colour="black", stroke=0.7)
```
# Make heatmap of the TFs
```{r clusterHeatmap-MT, fig.height=10, fig.width=10, echo=FALSE}
# Make heatmap
DoHeatmap(subset(sobj.org, downsample = 100), features = TF.genes, assay = "RNA", label = FALSE, group.by = 'cellID') 
DoHeatmap(subset(sobj, downsample = 100), features = TF.genes, assay = "RNA", label = FALSE, group.by = 'cellID')
```


# In the chunck below we visualize the network underlying the top 25 highly connected genes for each module
# Then we will also make a network plot combining all of the modules together. We take the user the top n highly connected genes per module, and other randomly selected genes, and constructs a joint network using the force-directed graph drawing algorithm inlcuding all the other modules in the network. This network uses the force-directed graph drawing algorithm
```{r Network construction, fig.height=10, fig.width=10, echo=FALSE}
# Save and construct an image of the top 25 hub genes per module
ModuleNetworkPlot(sobj, )

# Large hub gene network across modules using the force-directed graph drawing algorithm
HubGeneNetworkPlot(
  sobj,
  n_hubs = 5, n_other=40,
  edge_prop = 0.75,
  mods = 'all', vertex.label.cex = 1, )

# Here we run the UMAP algorithm on the hdWGCNA topological overlap matrix (TOM). For this UMAP analysis, the columns in the TOM are subsetted to only contain the top n hub genes by kME for each constructed module
sobj <- RunModuleUMAP(
  sobj,
  n_hubs = 10, # number of hub genes # change to dim(sobj)[1] to make sure all can be inlcuded for the later plot
  n_neighbors=15, # neighbors parameter for UMAP
  min_dist=0.1,    # min distance between points in UMAP space
)

# To load the transcription factors
# This will be directly added to the data tab in R
load(file="/Users/hamid/Desktop/ABG MSc project/Raw data/Ileum tissue/Wiarda - Ileum Tissue (non-immune)/WGCNA/Hub TFs/Hub_Transcription_Factors")
TF.per.module

# Now lets make a vector of the top transcription factors per module based on highest connectivity and lowest
# We will use t his for plotting the co-expression network
Top.TF.per.module <- c() # make empty list to store the top 2 TFs per module (keep in mind that the TFs in hte modules are already sorted based on low to high kMe)
for (i in 1:length(x = sobj@meta.data[14:length(sobj@meta.data)])) { # loop through the metadata columns containing the module names
  Top.TF.per.module <- append(Top.TF.per.module, tail(TF.per.module[[i]]$Symbol, n=1)) # Strongest hub TF
  Top.TF.per.module <- append(Top.TF.per.module, head(TF.per.module[[i]]$Symbol, n=1)) # Weakest hub TF
}
TFtable
# Some of the highly connected hubs per module
TF.hubs <- c('ZNF70',   'HES2', 'ELF3', 'SPDEF',   'YBX3', 'NME1', 'PHB',   'NFE2L2',   'HNF4G', 'MAF', 'NR1H4',   'CARHSP1',    'ID2', 'ZNFX1',   'HMGB2', 'E2F8', 'MYBL2',    'CDC5L')
# Here we plot the co-expression network and their relationships in UMAP space. 
# Each dot represents a single gene. The size of each dot is scaled by the genes kME.  
ModuleUMAPPlot(
  sobj,
  edge.alpha=0.5,
  sample_edges=TRUE,
  edge_prop=0.3, # proportion of edges to sample (20% here)
  label_hubs=0, # number of hubs to plot, we use our list of TFs instead, so setto 0
  keep_grey_edges=FALSE, label_genes = TF.hubs , wgcna_name = "trajectory_WGCAN.Ileum.Tiss", vertex.label.cex = 5) + geom_text_repel(aes(label = TFtable$gene_name), size = 5, box.padding = unit(0.35, "lines"), point.padding = unit(0.3, "lines"))

# Test code
#TF.per.module$`Ileum-M4`$Symbol

 
```

# In the chunk below we do GO/KEGG enrichment on the eignegnes per module based on higest connectivity scrore (top 20) on the tissue
```{r GO/KEGG enrich the eigen genes per module, fig.height=8, fig.width=9, echo=FALSE}
enrichR::listEnrichrDbs() # check what databases are available.

# Select databases of interest
dbs <- c('GO_Biological_Process_2023','GO_Cellular_Component_2023','GO_Molecular_Function_2023')

# Do the enrichment 
sobj <- RunEnrichr(
  sobj,
  dbs = dbs, 
  max_genes = Inf  # Inf to choose all genes or desired number
)

# Get the the output table
enrich_result <- GetEnrichrTable(sobj)
enrich_result

# make GO term plots:
EnrichrBarPlot(
  sobj,
  outdir = "enrichr_plots", # name directory to save
  n_terms = 10, # number of terms to show
  plot_size = c(5,10), # width, height of the images
  logscale=TRUE # show the enrichment as a log scale if desired
)

# Term: The name of the term (ie biological process, etc).
# Overlap: The fraction of genes overlapping between the module and the gene list.
# P.value: Fisher’s exact test p-value.
# Adjusted.P.value: Benjamini-Hochberg multiple testing correction for the Fisher’s exact test p-values.
# Odds.Ratio: statistic to quantify the association between the gene list in the current module and the gene list for the current Term.
# Combined.Score: natural log of the p-value multiplied by the z-score, where the z-score is the deviation from the expected rank.
# Genes: semicolon delimited list of gene symbols for the overlapping genes.
# db: the name of the Enrichr gene list.
# module: the name of the hdWGCNA module.


#### Now get the top genes per module with KMe > 0.5 ####
module_by.kME <- GetHubGenes(sobj, n_hubs = dim(sobj)[1], wgcna_name = "trajectory_WGCAN.Ileum.Tiss",) # get all the hub genes per module
# Sort based on kME
module_by.kME <- module_by.kME[order(module_by.kME$module, module_by.kME$kME, decreasing = TRUE),]
# only pick the ones with strong connectivity (KMe >= 0.5)
# module_by.kME <- subset(module_by.kME, kME >= 0.5) 
# Pick the top 25 per module
module_by.kME <- module_by.kME %>% group_by(module) %>% slice_max(n = 70, order_by = kME) #70 is enough for quick overview
module_by.kME

##### OR PICK THE EIGEN GENES PER MODULE

# Put the eigen genes of all modules in a list
#module_by.MEs <- sobj@misc[["trajectory_WGCAN.Ileum.Tiss"]][["wgcna_modules"]]
# Sort based on modules
#module_by.MEs <- module_by.MEs[order(module_by.MEs$module, decreasing = FALSE),]

# Extract the ganes and modules
GO.KEGG.sampels.pos <- module_by.kME[,1:2] # extract the genes and modules from column 1 and 2
GO.KEGG.sampels.pos <- split(GO.KEGG.sampels.pos$gene_name, GO.KEGG.sampels.pos$module)
GO.KEGG.sampels.pos[1] <- NULL # remove the grey module
# Prepare the GO KEGG analysis for the DE up-regulated markers using the PIG database
for (i in 1: length(GO.KEGG.sampels.pos)) {
  GO.KEGG.sampels.pos[[i]] = bitr(GO.KEGG.sampels.pos[[i]], fromType="SYMBOL", toType="ENTREZID", OrgDb="org.Hs.eg.db") # convert genes to human org.Hs.eg.db 
}
# do the same here, a line like below for each cluster
genelist.all.pos <- list()
for (i in 1: length(GO.KEGG.sampels.pos)) {
  genelist.all.pos[paste(i)] <- list(GO.KEGG.sampels.pos[[i]]$ENTREZID)
}

# PIG DATABSE
# Do the GO and KEGG on biological process on DE up-regulated markers
# GOclusterplot.all.pos <- compareCluster(geneCluster = genelist.all.pos, fun = "enrichGO", OrgDb = "org.Ss.eg.db", ont = 'BP', pvalueCutoff  = 0.05)
# dotplot(GOclusterplot.all.pos, showCategory=2) + ggtitle(paste("GO: Per Module", "Ileum Tissue", sep = " - ")) #+ coord_flip() + theme(axis.text.x = element_text(angle=90))

# HUMANS DATABASE GO
GOclusterplot.all.pos.hs <- compareCluster(geneCluster = genelist.all.pos, fun = "enrichGO", OrgDb = "org.Hs.eg.db", ont = 'BP', pvalueCutoff  = 0.05) # PB, CC
dotplot(GOclusterplot.all.pos.hs, showCategory=2) + ggtitle(paste("GO: Per Module", "Ileum Tissue", sep = " - ")) + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 14, colour = "black")) +theme(axis.text.y = element_text(angle = 0, hjust = 1, size = 14, colour = "black")) #+ coord_flip()

# No we generate a dotplot of GO pathways that we think makes sense within the statistically significant once.
# Before we only plotted the top 2, but these are not always the most relevant.
GO.table <- GOclusterplot.all.pos.hs@compareClusterResult # we save the result obtained from the GO enrichment in a new list of vectors
#GO.table # take a look for a second to see the order of the columns. 
#colnames(GO.table) # check column names that we will use to extract the data of interest
GO.table$p.adjust <- as.numeric(GO.table$p.adjust) # lets make the adjusted p-value numeric, so that we can use it in the legend of the final plot
GO.table$GeneRatio <- as.numeric(sapply(strsplit(GO.table$GeneRatio, "/"), function(x) as.numeric(x[1])/as.numeric(x[2])))  # lets make the generatio numeric, so that we can use it in the legend of the final plot. since its a string of ratio (e.g. 20/70), we have to splot by "/" and divide
# By manually analyzing the table, we will extract the index of the GO terms and put the top 3 per cluster in a table
view(GO.table)
# Pick the GO terms of interest (FULL) in the order of the cells
GO.terms <- c(paste(GO.table$Description[9], GO.table$ID[9], sep = " - "), paste(GO.table$Description[42], GO.table$ID[42], sep = " - "), paste(GO.table$Description[99], GO.table$ID[99], sep = " - "), paste(GO.table$Description[160], GO.table$ID[160], sep = " - "), paste(GO.table$Description[277], GO.table$ID[277], sep = " - "), paste(GO.table$Description[280], GO.table$ID[280], sep = " - "), paste(GO.table$Description[284], GO.table$ID[284], sep = " - "), paste(GO.table$Description[285], GO.table$ID[285], sep = " - "), paste(GO.table$Description[288], GO.table$ID[288], sep = " - "), paste(GO.table$Description[290], GO.table$ID[290], sep = " - "), paste(GO.table$Description[336], GO.table$ID[336], sep = " - "), paste(GO.table$Description[338], GO.table$ID[338], sep = " - "), paste(GO.table$Description[342], GO.table$ID[342], sep = " - "), paste(GO.table$Description[343], GO.table$ID[343], sep = " - "), paste(GO.table$Description[422], GO.table$ID[422], sep = " - "), paste(GO.table$Description[423], GO.table$ID[423], sep = " - "), paste(GO.table$Description[424], GO.table$ID[424], sep = " - "), paste(GO.table$Description[427], GO.table$ID[427], sep = " - "), paste(GO.table$Description[429], GO.table$ID[429], sep = " - "), paste(GO.table$Description[444], GO.table$ID[444], sep = " - "), paste(GO.table$Description[456], GO.table$ID[456], sep = " - "), paste(GO.table$Description[471], GO.table$ID[471], sep = " - "), paste(GO.table$Description[488], GO.table$ID[488], sep = " - "), paste(GO.table$Description[492], GO.table$ID[492], sep = " - ") , paste(GO.table$Description[499], GO.table$ID[499], sep = " - "), paste(GO.table$Description[502], GO.table$ID[502], sep = " - "), paste(GO.table$Description[504], GO.table$ID[504], sep = " - "), paste(GO.table$Description[505], GO.table$ID[505], sep = " - "), paste(GO.table$Description[521], GO.table$ID[521], sep = " - "), paste(GO.table$Description[522], GO.table$ID[522], sep = " - "), paste(GO.table$Description[523], GO.table$ID[523], sep = " - "), paste(GO.table$Description[524], GO.table$ID[524], sep = " - "), paste(GO.table$Description[523], GO.table$ID[523], sep = " - "), paste(GO.table$Description[720], GO.table$ID[720], sep = " - "), paste(GO.table$Description[721], GO.table$ID[721], sep = " - "))

# Pic the GO terms of interest (index) (for filtering the full table)
GO.terms.index <- c(paste(GO.table$Description[9]), paste(GO.table$Description[42]), paste(GO.table$Description[99]), paste(GO.table$Description[160]), paste(GO.table$Description[277]), paste(GO.table$Description[280]), paste(GO.table$Description[284]), paste(GO.table$Description[285]), paste(GO.table$Description[288]), paste(GO.table$Description[290]), paste(GO.table$Description[336]), paste(GO.table$Description[338]), paste(GO.table$Description[342]), paste(GO.table$Description[343]), paste(GO.table$Description[422]), paste(GO.table$Description[423]), paste(GO.table$Description[424]), paste(GO.table$Description[427]), paste(GO.table$Description[429]), paste(GO.table$Description[444]), paste(GO.table$Description[456]), paste(GO.table$Description[471]), paste(GO.table$Description[488]), paste(GO.table$Description[492]), paste(GO.table$Description[499]), paste(GO.table$Description[502]), paste(GO.table$Description[504]), paste(GO.table$Description[505]), paste(GO.table$Description[521]), paste(GO.table$Description[522]), paste(GO.table$Description[523]), paste(GO.table$Description[524]), paste(GO.table$Description[523]), paste(GO.table$Description[720]), paste(GO.table$Description[721]))

# Now only keep the GO terms of interest from the full data
GO.table <- GO.table[GO.table$Description %in% GO.terms.index, ]
# Now combine the GO term ID and Description in new column to use for plotting
GO.table$term <- paste(GO.table$Description, " - ", GO.table$ID)

# Dotplot the GO terms of interest
ggplot(GO.table) +
  geom_point(aes(x = reorder(term, GeneRatio, decreasing = T), 
                 y = Cluster,
                 size = GeneRatio,
                 fill = p.adjust), colour="black", shape=21, stroke = 0.5) +  #colour="black", shape=21, stroke = 0.5
  theme_bw() +
  scale_color_gradient(low = 'red', high = 'blue') +
  coord_flip() + coord_flip() +  
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 12, colour = "black")) + 
  theme(axis.text.y = element_text(angle = 0, hjust = 1, size = 12, colour = "black")) 


#### NOW DO THE SAME FOR CELLULAR COMPONENT #####

# HUMANS DATABASE GO
GOclusterplot.all.pos.hs <- compareCluster(geneCluster = genelist.all.pos, fun = "enrichGO", OrgDb = "org.Hs.eg.db", ont = 'CC', pvalueCutoff  = 0.05) # PB, CC
dotplot(GOclusterplot.all.pos.hs, showCategory=2) + ggtitle(paste("GO: Per Module", "Ileum Tissue", sep = " - ")) + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 14, colour = "black")) +theme(axis.text.y = element_text(angle = 0, hjust = 1, size = 14, colour = "black")) #+ coord_flip()
```
# KEGG
```{r KEGG enrichment on the DE genes, fig.height=7.5, fig.width=14, echo=FALSE}
# PIG DATABSE
# KEGG
# suported orgnaism can ben found here: https://www.genome.jp/kegg/catalog/org_list.html
#KEGGclusterplot.all.pos <- compareCluster(geneCluster = genelist.all.pos, fun = "enrichKEGG", organism = "ssc", pvalueCutoff  = 0.05)
#dotplot(KEGGclusterplot.all.pos, showCategory=2) + ggtitle(paste("KEGG: Per Module", "Ileum Tissue", sep = " - "))# + coord_flip() + theme(axis.text.x = element_text(angle=90))

# HUMANS DATABASE
# KEGG
KEGGclusterplot.all.pos <- compareCluster(geneCluster = genelist.all.pos, fun = "enrichKEGG", organism = "hsa", pvalueCutoff  = 0.05)
dotplot(KEGGclusterplot.all.pos, showCategory=2) + ggtitle(paste("KEGG: Per Module", "Ileum Tissue", sep = " - "))
```

# In the chunck below we will now determine to what extend the differntially expressed genes in a cell population in both organoid and tissue overlaps the genes in the co-expression modules. This could help us to see how the eigen genes differ in organoid vs tissue. If the eigengenes in a module are not present in the DEGs of the organoid, then the highly connected transcription fators that are not expressed in that module in the oirganoid could be the reasons why those eigengenes are turned off. If those eigen genes happen to be maturation markers, then it could potentially explain the lack of maturation in the organoid (THIS IS NOT INCLUDED IN THE FINAL RESULTS)
# In the second part we will check for module preservation in the organoid.  If we think about co-expression networks from this perspective, we need a way to statistically quantify the conservation of co-expression modules that were identified in tissue across organoid.
# Then we will check the hub genes found in the organoid modules. If the hub genes are not the same between organoid and tissue, the could suggest that they dont share many module eigen genes associated with maturation 
```{r DEG vs module geens, fig.height=10, fig.width=10, echo=FALSE}
# First we compute the DEGs using our previous Seurat method (wilcox)
# Tissue
Idents(sobj) <- sobj$cellID # Change the current idenent to cellID
sobj$cellID <- factor(sobj$cellID, levels = c('Prolific Stem/Prog *', 'EC Prog *', 'Developing EC *', 'Early EC *', 'Late EC *', 'PC *', 'GC *', 'EEC *', 'TC *'))
sobj.markers <- Seurat::FindAllMarkers(
  sobj, only.pos = TRUE, min.pct = 0.15, logfc.threshold = 1  # expressed in at least 15% of the cells with minimal LogFC at 0.1 to include weak signal
) 
sobj.markers <- subset(sobj.markers, p_val_adj < 0.05) # make sure the adjusted p-values are still < 0.05 since some genes in DE list have p_val_adj > 

# compute marker gene overlaps
sobj.overlapping.DEG.Module <- OverlapModulesDEGs(
  sobj, deg_df = sobj.markers, fc_cutoff = 1,# log fold change cutoff for overlap analysis
)
sobj.overlapping.DEG.Module
# Plot the overlaps of the DEGs and module eigengenes in barplot for each cell type
plot.overlap.sobj <- OverlapBarPlot(sobj.overlapping.DEG.Module,  plot_var = "Jaccard") # we can also do Fisher "pval", or "fdr" which is False Discovery Rate (FDR) multiple testing correction for the Fisher’s p-values. Or "Jaccard" index
# Plot the bars
wrap_plots(plot.overlap.sobj, ncol=3,)

# plot odds ratio of the overlap as a dot plot
OverlapDotPlot(
  sobj.overlapping.DEG.Module,
  plot_var = 'odds_ratio') +
  ggtitle('Overlap of modules & cell-type markers')

# Orgnaoid
# First we compute the DEGs using our previous Seurat method (wilcox)
# Tissue
Idents(sobj_query) <- sobj_query$cellID # Change the current idenent to cellID
sobj_query$cellID <- factor(sobj_query$cellID, levels = c('Prolific Stem/Prog', 'Prolific TAC', 'TAC', 'Early EC Prog', 'Late EC Prog', 'Renewing EC', 'Developing EC', 'Undeveloped EC', 'Early Immature EC', 'Late Immature EC', 'Migrating EC (Villous Tips)', 'Semi-Mature EC', 'Resting Cells', "PC", "GC", "EEC"))

sobj_query.markers <- Seurat::FindAllMarkers(
  sobj_query, only.pos = TRUE, min.pct = 0.15, logfc.threshold = 1 
) 
sobj_query.markers <- subset(sobj_query.markers, p_val_adj < 0.05)
# compute marker gene overlaps
sobj_query.overlapping.DEG.Module <- OverlapModulesDEGs(
  sobj_query, deg_df = sobj_query.markers, fc_cutoff = 1
)
sobj_query.overlapping.DEG.Module
# Plot the overlaps of the DEGs and module eigengenes in barplot for each cell type
plot.overlap.sobj_query <- OverlapBarPlot(sobj_query.overlapping.DEG.Module,  plot_var = "Jaccard") 
# Plot the bars
wrap_plots(plot.overlap.sobj_query, ncol=3,)

# plot odds ratio of the overlap as a dot plot
OverlapDotPlot(
  sobj_query.overlapping.DEG.Module,
  plot_var = 'odds_ratio') +
  ggtitle('Overlap of modules vs DEGS: ORGANOID')

OverlapDotPlot(
  sobj.overlapping.DEG.Module,
  plot_var = 'odds_ratio') +
  ggtitle('Overlap of modules vs DEGS: TISSUE')

wrap_plots(plot.overlap.sobj, ncol=3,)
wrap_plots(plot.overlap.sobj_query, ncol=3,)





# We previously mapped the module from the tissue to the organoid, so we skip this part
# So now can set up the expression matrices for the tissue and organoid datasets. Since we already have made the expression matrix for the tissue, we now will make one for the organised

# define groups
org.groups = c('Prolific Stem/Prog', 'Prolific TAC', 'TAC', 'Early EC Prog', 'Late EC Prog', 'Renewing EC', 'Developing EC', 'Undeveloped EC', 'Early Immature EC', 'Late Immature EC', 'Migrating EC (Villous Tips)', 'Semi-Mature EC', 'Resting Cells', "PC", "GC", "EEC")

sobj_query <- MetacellsByGroups(
  seurat_obj = sobj_query,
  group.by = "cellID",
  k = 4, # K4 is the maximum we can use for this dataset, as the smalles number is cells are the EECs
  target_metacells=dim(sobj_query)[2], # dim(sobj)[2] is the maximum number of cells in our data
  ident.group = 'cellID',
  min_cells=0, # set to 0 because we want to include all cells
  max_shared=10, assay = 'RNA', 
  slot = "counts", )

# Normalize our new object containing the WGCNA metacells
sobj_query <- NormalizeMetacells(sobj_query)

# Here we are going to choose the expression matrix that we will use for the WGCNA network analysis
# In order to continue with the normalized count matrix, we will specify that using the data slot
sobj_query <- SetDatExpr(
  sobj_query,
  group.by='cellID',
  group_name = org.groups, 
  assay = "RNA", 
  slot = "data", # we use the normalized count matrix
  use_metacells = TRUE, 
)

# Now we will check to what extend the modules are preserved in organoid
# run module preservation function
sobj_query <- ModulePreservation(
  sobj_query,
  seurat_ref = sobj, # pick the tissue as reference
  name = "ModulePreservation-Organoid",
  verbose=3,
  n_permutations=250, 
)

# Now extract the module preservation table that we made
preserved.module <- GetModulePreservation(sobj_query, "ModulePreservation-Organoid")$Z
osbderved.difference <- GetModulePreservation(sobj_query, "ModulePreservation-Organoid")$obs

grep('summary', colnames(preserved.module))
grep('summary', colnames(osbderved.difference))

# Plot the summary Z-scaore and p-value
plot_preserved_modules <- PlotModulePreservation(
  sobj_query,
  name="ModulePreservation-Organoid",
  statistics = "summary",
)
wrap_plots(plot_preserved_modules, ncol=2)

plot_preserved_modules 
```

# Now lets do a differential module eigen gene analysis (DME) to see which modules are differentially exppressed in which cell population in both organoid and tissue
# We are essential doing same as the dotplots as before when we projected the module eigengens from the tissue onto the organoid, but now we will include a  Wilcoxon test to compare two groups. 
# THIS PART IS NOT INCLUDED IN THE FINAL RESULTS
```{r DEG vs module geens, fig.height=7, fig.width=14, echo=FALSE}
# TISSUE
# Lets define our cell types to loop through and order them according to pseudotime
groups <- c('Prolific Stem/Prog *', 'EC Prog *', 'PC *', 'Developing EC *', 'TC *', 'Early EC *', 'GC *', 'EEC *', 'Late EC *')
# Now make a empty dataframe to store the DMEs for later
tisse.DMEs <- data.frame()
# loop through the cell types
for (i in 1:length(x = groups)) {
  # Find the cells in the cell types that we want to compare
  g1 <- sobj@meta.data %>% subset(cellID == groups[i]) %>% rownames # pick one group
  g2 <- sobj@meta.data %>% subset(cellID != groups[i]) %>% rownames # now pick the group that is not equal to group 1, a.k.a all the others
  # Do the DME test using WGCNA method
  # Note that we do not include LogFC treshold as we want to include all gnees found in a module
  sobj.DMEs <- FindDMEs(
    sobj,
    barcodes1 = g1,
    barcodes2 = g2,
    test.use='wilcox',
    wgcna_name = "trajectory_WGCAN.Ileum.Tiss", harmonized = F, min.pct = 0.5
  )
  # Add a cluster columns to the new object to store the cell type names
  sobj.DMEs$cluster <- groups[i]
  # And finally append to the empty table
  tisse.DMEs <- rbind(tisse.DMEs, sobj.DMEs)
}
# Not lets plot it on a heatmap as we previously have done in Seurat
# Retrieve the modules from the Seurat object
modules.sobj <- GetModules(sobj)
# now get the names of the modules (but not the grey one, that is useless)
module.names <- levels(modules.sobj$module); module.names <- module.names[module.names != 'grey']
# Make a copy of the DME table for plotting
tisse.DMEs_df <- tisse.DMEs
# Order the module names correctle from Ileam-M1 to Ileum-M2
tisse.DMEs_df$module <- factor(as.character(tisse.DMEs_df$module), levels=module.names)
# Now we set the maximum and miimum treshold gor the Log2FC that will be used for color scaling for the legend and heatmap
maxlog2fc <- 2; minlog2fc <- -1
tisse.DMEs_df$avg_log2FC <- ifelse(tisse.DMEs_df$avg_log2FC > maxlog2fc, maxlog2fc, tisse.DMEs_df$avg_log2FC)
tisse.DMEs_df$avg_log2FC <- ifelse(tisse.DMEs_df$avg_log2FC < minlog2fc, minlog2fc, tisse.DMEs_df$avg_log2FC)
# Now add the significance column to the DME dataframe
tisse.DMEs_df$sign <- gtools::stars.pval(tisse.DMEs_df$p_val_adj) # its already stored in p_val_adj column
# change test color (black and white are easy to see)
tisse.DMEs_df$textcolor <- ifelse(tisse.DMEs_df$avg_log2FC > 0.2, 'black', 'black') # set the text color of the significance stars on black
# make  heatmap using geom_tile
heatmap <- tisse.DMEs_df %>% 
  ggplot(aes(y=factor(cluster, levels = groups), x=module, fill=avg_log2FC)) +
  geom_tile() 
# add the significance levels
heatmap <- heatmap + 
  geom_text(label=tisse.DMEs_df$sign, color=tisse.DMEs_df$textcolor) 
# customize the color and theme of the plot
heatmap <- heatmap + 
  scale_fill_gradient2(low='cyan2', mid='white', high='red2') +
  RotatedAxis() +
  theme(
    panel.border = element_rect(fill=NA, color='black', size=1),
    axis.line.x = element_blank(),
    axis.line.y = element_blank(),
    plot.margin=margin(0,0,0,0)
  ) + xlab('') + ylab('') +
  coord_equal()
# Plot heatmap for tissue
heatmap



# Now do the same for organoid
groups <- c('Prolific Stem/Prog', 'Prolific TAC', 'Early EC Prog', 'Late EC Prog', 'TAC', 'Developing EC', 'Renewing EC', "EEC", "PC", "GC", 'Resting Cells', 'Early Immature EC', 'Semi-Mature EC', 'Migrating EC (Villous Tips)', 'Late Immature EC', 'Undeveloped EC')
Org.DMEs <- data.frame()
# loop through the cell types
for (i in 1:length(x = groups)) {
  g1 <- sobj_query@meta.data %>% subset(cellID == groups[i]) %>% rownames 
  g2 <- sobj_query@meta.data %>% subset(cellID != groups[i]) %>% rownames 
  sobj_query.DMEs <- FindDMEs(
    sobj_query,
    barcodes1 = g1,
    barcodes2 = g2,
    test.use='wilcox',
    wgcna_name = "trajectory_WGCAN.Ileum.Org.Projected", harmonized = F, min.pct = 0.50 # pick the correct project
  )
  sobj_query.DMEs$cluster <- groups[i]
  Org.DMEs <- rbind(Org.DMEs, sobj_query.DMEs)
}
modules.sobj_query.DMEs <- GetModules(sobj_query)
module.names <- levels(modules.sobj_query.DMEs$module); module.names <- module.names[module.names != 'grey']
Org.DMEs_df <- Org.DMEs
Org.DMEs_df$module <- factor(as.character(Org.DMEs_df$module), levels=module.names)
maxlog2fc <- 2; minlog2fc <- -1
Org.DMEs_df$avg_log2FC <- ifelse(Org.DMEs_df$avg_log2FC > maxlog2fc, maxlog2fc, Org.DMEs_df$avg_log2FC)
Org.DMEs_df$avg_log2FC <- ifelse(Org.DMEs_df$avg_log2FC < minlog2fc, minlog2fc, Org.DMEs_df$avg_log2FC)
Org.DMEs_df$sign <- gtools::stars.pval(Org.DMEs_df$p_val_adj) 
Org.DMEs_df$textcolor <- ifelse(Org.DMEs_df$avg_log2FC > 0.2, 'black', 'black') 
heatmap <- Org.DMEs_df %>% 
  ggplot(aes(y=factor(cluster, levels = groups), x=module, fill=avg_log2FC)) +
  geom_tile() 
heatmap <- heatmap + 
  geom_text(label=Org.DMEs_df$sign, color=Org.DMEs_df$textcolor) 
heatmap <- heatmap + 
  scale_fill_gradient2(low='cyan2', mid='white', high='red2') +
  RotatedAxis() +
  theme(
    panel.border = element_rect(fill=NA, color='black', size=1),
    axis.line.x = element_blank(),
    axis.line.y = element_blank(),
    plot.margin=margin(0,0,0,0)
  ) + xlab('') + ylab('') +
  coord_equal()
# Plot heatmap for organoid
heatmap

```

# try to save the WGCNA analyzed Seurat object
```{r Save WGCNA analyzed Seurat object, echo=FALSE}
# Save the Seurat object
SaveH5Seurat(sobj, overwrite = TRUE, filename = "WGCNA-anayzed.ileum_pig_tiss(WIERDA).epithel.v4") # gives error
```